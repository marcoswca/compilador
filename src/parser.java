
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Thu Feb 23 16:47:34 BRT 2017
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.*;
import symbTable.*;
import tipo.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Thu Feb 23 16:47:34 BRT 2017
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\362\000\002\002\006\000\002\002\004\000\002\003" +
    "\004\000\002\176\002\000\002\003\010\000\002\004\005" +
    "\000\002\004\003\000\002\177\002\000\002\006\011\000" +
    "\002\007\006\000\002\010\005\000\002\200\002\000\002" +
    "\010\005\000\002\010\002\000\002\011\005\000\002\011" +
    "\003\000\002\012\003\000\002\013\004\000\002\013\002" +
    "\000\002\014\004\000\002\014\003\000\002\015\006\000" +
    "\002\201\002\000\002\015\005\000\002\016\003\000\002" +
    "\016\005\000\002\017\003\000\002\017\005\000\002\020" +
    "\003\000\002\020\005\000\002\021\004\000\002\021\003" +
    "\000\002\022\003\000\002\022\005\000\002\023\003\000" +
    "\002\023\005\000\002\023\003\000\002\023\004\000\002" +
    "\024\003\000\002\024\004\000\002\024\003\000\002\173" +
    "\003\000\002\173\003\000\002\025\003\000\002\025\003" +
    "\000\002\025\003\000\002\026\004\000\002\026\002\000" +
    "\002\027\004\000\002\027\003\000\002\030\006\000\002" +
    "\202\002\000\002\030\005\000\002\031\003\000\002\031" +
    "\003\000\002\031\003\000\002\031\003\000\002\031\003" +
    "\000\002\031\003\000\002\031\003\000\002\033\003\000" +
    "\002\033\003\000\002\033\003\000\002\034\003\000\002" +
    "\034\003\000\002\035\005\000\002\036\005\000\002\037" +
    "\003\000\002\037\004\000\002\040\003\000\002\040\003" +
    "\000\002\040\003\000\002\040\003\000\002\041\010\000" +
    "\002\042\005\000\002\042\003\000\002\043\003\000\002" +
    "\044\003\000\002\044\003\000\002\045\003\000\002\046" +
    "\005\000\002\046\007\000\002\046\005\000\002\047\005" +
    "\000\002\047\003\000\002\050\005\000\002\052\005\000" +
    "\002\052\003\000\002\053\005\000\002\053\003\000\002" +
    "\055\003\000\002\056\003\000\002\057\005\000\002\060" +
    "\003\000\002\061\005\000\002\062\004\000\002\063\003" +
    "\000\002\064\004\000\002\064\002\000\002\065\004\000" +
    "\002\065\003\000\002\066\006\000\002\203\002\000\002" +
    "\066\005\000\002\067\004\000\002\067\002\000\002\070" +
    "\005\000\002\070\003\000\002\071\003\000\002\071\003" +
    "\000\002\072\005\000\002\072\005\000\002\073\003\000" +
    "\002\204\002\000\002\073\005\000\002\074\003\000\002" +
    "\074\003\000\002\075\005\000\002\076\005\000\002\076" +
    "\003\000\002\077\003\000\002\077\003\000\002\077\003" +
    "\000\002\077\003\000\002\100\005\000\002\101\006\000" +
    "\002\102\003\000\002\103\003\000\002\104\004\000\002" +
    "\107\003\000\002\110\005\000\002\110\005\000\002\110" +
    "\005\000\002\111\006\000\002\205\002\000\002\111\007" +
    "\000\002\032\003\000\002\105\004\000\002\112\003\000" +
    "\002\113\003\000\002\114\005\000\002\115\005\000\002" +
    "\115\003\000\002\116\003\000\002\116\003\000\002\117" +
    "\005\000\002\117\003\000\002\120\005\000\002\120\003" +
    "\000\002\121\003\000\002\121\003\000\002\121\003\000" +
    "\002\121\003\000\002\121\003\000\002\121\003\000\002" +
    "\121\003\000\002\121\002\000\002\122\003\000\002\122" +
    "\003\000\002\122\003\000\002\005\010\000\002\123\005" +
    "\000\002\124\005\000\002\125\006\000\002\126\006\000" +
    "\002\131\005\000\002\132\003\000\002\132\003\000\002" +
    "\132\003\000\002\132\004\000\002\133\006\000\002\134" +
    "\005\000\002\134\003\000\002\135\003\000\002\136\005" +
    "\000\002\137\004\000\002\137\003\000\002\140\005\000" +
    "\002\141\005\000\002\141\003\000\002\142\003\000\002" +
    "\142\005\000\002\142\007\000\002\143\004\000\002\144" +
    "\003\000\002\145\003\000\002\106\003\000\002\106\003" +
    "\000\002\146\003\000\002\147\005\000\002\147\003\000" +
    "\002\150\003\000\002\151\003\000\002\151\005\000\002" +
    "\152\003\000\002\152\005\000\002\153\003\000\002\153" +
    "\005\000\002\154\004\000\002\154\003\000\002\155\003" +
    "\000\002\155\005\000\002\156\003\000\002\156\003\000" +
    "\002\156\003\000\002\156\003\000\002\156\005\000\002" +
    "\156\004\000\002\156\003\000\002\156\003\000\002\157" +
    "\003\000\002\157\003\000\002\157\003\000\002\160\003" +
    "\000\002\160\003\000\002\161\003\000\002\162\003\000" +
    "\002\163\004\000\002\164\005\000\002\164\004\000\002" +
    "\165\005\000\002\165\003\000\002\166\005\000\002\166" +
    "\003\000\002\171\003\000\002\171\003\000\002\171\003" +
    "\000\002\172\003\000\002\172\003\000\002\172\003\000" +
    "\002\172\003\000\002\172\003\000\002\167\003\000\002" +
    "\167\003\000\002\167\003\000\002\167\003\000\002\167" +
    "\003\000\002\167\003\000\002\167\003\000\002\170\003" +
    "\000\002\174\003\000\002\175\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u0163\000\004\040\006\001\002\000\004\002\u0165\001" +
    "\002\000\004\055\021\001\002\000\004\057\010\001\002" +
    "\000\006\055\uffff\073\ufffe\001\002\000\100\007\uff12\011" +
    "\uff12\012\uff12\013\uff12\014\uff12\015\uff12\016\uff12\017\uff12" +
    "\020\uff12\021\uff12\022\uff12\031\uff12\045\uff12\055\uff12\056" +
    "\uff12\061\uff12\062\uff12\063\uff12\065\uff12\066\uff12\067\uff12" +
    "\070\uff12\071\uff12\072\uff12\073\uff12\074\uff12\075\uff12\100" +
    "\uff12\102\uff12\103\uff12\104\uff12\001\002\000\004\073\012" +
    "\001\002\000\004\057\014\001\002\000\006\063\015\102" +
    "\017\001\002\000\010\062\ufffb\063\ufffb\102\ufffb\001\002" +
    "\000\032\010\uff10\012\uff10\014\uff10\034\uff10\057\uff10\060" +
    "\uff10\064\uff10\071\uff10\073\uff10\101\uff10\111\uff10\112\uff10" +
    "\001\002\000\004\057\020\001\002\000\004\055\ufffd\001" +
    "\002\000\010\062\ufffc\063\ufffc\102\ufffc\001\002\000\044" +
    "\003\uff11\005\uff11\006\uff11\022\uff11\024\uff11\025\uff11\026" +
    "\uff11\027\uff11\033\uff11\037\uff11\043\uff11\046\uff11\052\uff11" +
    "\053\uff11\055\uff11\057\uff11\064\uff11\001\002\000\022\003" +
    "\023\005\ufff4\006\ufff4\026\ufff4\033\024\037\ufff4\046\ufff4" +
    "\052\ufff4\001\002\000\004\055\ufff6\001\002\000\004\064" +
    "\226\001\002\000\016\005\uffef\006\030\026\uffef\037\uffef" +
    "\046\uffef\052\uffef\001\002\000\004\056\027\001\002\000" +
    "\004\002\001\001\002\000\006\003\u013e\057\010\001\002" +
    "\000\014\005\uffd2\026\uffd2\037\uffd2\046\033\052\uffd2\001" +
    "\002\000\012\005\uff9f\026\uff9f\037\uff9f\052\154\001\002" +
    "\000\006\003\036\057\010\001\002\000\004\066\043\001" +
    "\002\000\016\003\uffd0\005\uffd0\026\uffd0\037\uffd0\052\uffd0" +
    "\057\uffd0\001\002\000\004\055\uffce\001\002\000\016\003" +
    "\036\005\uffd3\026\uffd3\037\uffd3\052\uffd3\057\010\001\002" +
    "\000\016\003\uffd1\005\uffd1\026\uffd1\037\uffd1\052\uffd1\057" +
    "\uffd1\001\002\000\004\055\021\001\002\000\016\003\uffcd" +
    "\005\uffcd\026\uffcd\037\uffcd\052\uffcd\057\uffcd\001\002\000" +
    "\046\004\101\012\073\014\044\036\056\041\072\042\070" +
    "\044\065\057\055\060\050\064\105\073\061\077\066\101" +
    "\077\104\063\105\075\106\064\107\100\110\051\001\002" +
    "\000\032\010\uffd8\012\uffd8\014\uffd8\034\uffd8\057\uffd8\060" +
    "\uffd8\064\uffd8\071\uffd8\073\uffd8\101\uffd8\111\uffd8\112\uffd8" +
    "\001\002\000\016\022\uffd5\055\uffd5\063\uffd5\065\uffd5\100" +
    "\uffd5\102\uffd5\001\002\000\004\065\152\001\002\000\010" +
    "\022\uffb9\055\uffb9\102\uffb9\001\002\000\016\022\uffd9\055" +
    "\uffd9\063\uffd9\065\uffd9\100\uffd9\102\uffd9\001\002\000\010" +
    "\022\uffc8\055\uffc8\102\uffc8\001\002\000\016\022\uffdb\055" +
    "\uffdb\063\uffdb\065\uffdb\100\uffdb\102\uffdb\001\002\000\010" +
    "\022\uffc3\055\uffc3\102\uffc3\001\002\000\014\022\uffc2\055" +
    "\uffc2\063\uffc2\100\uffc2\102\uffc2\001\002\000\012\022\uffcc" +
    "\055\uffcc\065\uff12\102\uffcc\001\002\000\012\004\101\041" +
    "\072\042\070\077\066\001\002\000\010\022\uffc4\055\uffc4" +
    "\102\uffc4\001\002\000\010\022\uffcb\055\uffcb\102\uffcb\001" +
    "\002\000\004\057\014\001\002\000\010\022\uffbb\055\uffbb" +
    "\102\uffbb\001\002\000\004\057\010\001\002\000\010\022" +
    "\uffc6\055\uffc6\102\uffc6\001\002\000\010\022\uffca\055\uffca" +
    "\102\uffca\001\002\000\004\035\143\001\002\000\014\022" +
    "\uffc1\055\uffc1\063\uffc1\100\uffc1\102\uffc1\001\002\000\004" +
    "\035\140\001\002\000\010\022\uffc5\055\uffc5\102\uffc5\001" +
    "\002\000\004\057\014\001\002\000\032\010\uffd7\012\uffd7" +
    "\014\uffd7\034\uffd7\057\uffd7\060\uffd7\064\uffd7\071\uffd7\073" +
    "\uffd7\101\uffd7\111\uffd7\112\uffd7\001\002\000\004\055\021" +
    "\001\002\000\010\022\uffc9\055\uffc9\102\uffc9\001\002\000" +
    "\010\022\uffbc\055\uffbc\102\uffbc\001\002\000\016\022\uffd4" +
    "\055\uffd4\063\uffd4\065\uffd4\100\uffd4\102\uffd4\001\002\000" +
    "\010\022\uffc7\055\uffc7\102\uffc7\001\002\000\004\071\107" +
    "\001\002\000\010\057\010\064\105\101\077\001\002\000" +
    "\010\022\uffbe\055\uffbe\102\uffbe\001\002\000\010\022\uffba" +
    "\055\uffba\102\uffba\001\002\000\016\022\uffd6\055\uffd6\063" +
    "\uffd6\065\uffd6\100\uffd6\102\uffd6\001\002\000\016\022\uffda" +
    "\055\uffda\063\uffda\065\uffda\100\uffda\102\uffda\001\002\000" +
    "\020\012\073\014\044\057\010\060\050\064\105\073\061" +
    "\101\077\001\002\000\006\063\uffb5\100\uffb5\001\002\000" +
    "\016\022\uffb3\055\uffb3\063\uffb3\065\uffd5\100\uffb3\102\uffb3" +
    "\001\002\000\006\063\015\100\116\001\002\000\006\063" +
    "\uffb6\100\uffb6\001\002\000\014\022\uffb4\055\uffb4\063\uffb4" +
    "\100\uffb4\102\uffb4\001\002\000\020\012\073\014\044\057" +
    "\010\060\050\064\105\073\061\101\077\001\002\000\004" +
    "\035\117\001\002\000\046\004\101\012\073\014\044\036" +
    "\056\041\072\042\070\044\065\057\055\060\050\064\105" +
    "\073\061\077\066\101\077\104\063\105\075\106\064\107" +
    "\100\110\051\001\002\000\010\022\uffb2\055\uffb2\102\uffb2" +
    "\001\002\000\010\022\uffb8\055\uffb8\102\uffb8\001\002\000" +
    "\006\063\uffb7\100\uffb7\001\002\000\016\003\uffcf\005\uffcf" +
    "\026\uffcf\037\uffcf\052\uffcf\057\uffcf\001\002\000\004\022" +
    "\137\001\002\000\006\022\uffad\055\uffad\001\002\000\006" +
    "\022\133\055\021\001\002\000\006\062\130\063\015\001" +
    "\002\000\046\004\101\012\073\014\044\036\056\041\072" +
    "\042\070\044\065\057\055\060\050\064\105\073\061\077" +
    "\066\101\077\104\063\105\075\106\064\107\100\110\051" +
    "\001\002\000\006\022\uffac\055\uffac\001\002\000\004\057" +
    "\014\001\002\000\010\022\uffb1\055\uffb1\102\uffb1\001\002" +
    "\000\004\022\136\001\002\000\006\022\uffae\055\uffae\001" +
    "\002\000\010\022\uffb0\055\uffb0\102\uffb0\001\002\000\010" +
    "\022\uffaf\055\uffaf\102\uffaf\001\002\000\020\012\073\014" +
    "\044\057\010\060\050\064\105\073\061\101\077\001\002" +
    "\000\010\022\uffa4\055\uffa4\102\uffa4\001\002\000\010\022" +
    "\uffa5\055\uffa5\102\uffa5\001\002\000\046\004\101\012\073" +
    "\014\044\036\056\041\072\042\070\044\065\057\055\060" +
    "\050\064\105\073\061\077\066\101\077\104\063\105\075" +
    "\106\064\107\100\110\051\001\002\000\010\022\uffa3\055" +
    "\uffa3\102\uffa3\001\002\000\010\022\uffa1\055\uffa1\102\uffa1" +
    "\001\002\000\010\022\uffa2\055\uffa2\102\uffa2\001\002\000" +
    "\006\063\015\102\150\001\002\000\014\022\uffc0\055\uffc0" +
    "\063\uffc0\100\uffc0\102\uffc0\001\002\000\010\022\uffbd\055" +
    "\uffbd\102\uffbd\001\002\000\016\012\073\014\044\057\010" +
    "\060\050\064\105\101\077\001\002\000\014\022\uffbf\055" +
    "\uffbf\063\uffbf\100\uffbf\102\uffbf\001\002\000\006\003\u0135" +
    "\057\014\001\002\000\010\005\uff98\026\166\037\161\001" +
    "\002\000\006\055\021\073\uff7b\001\002\000\004\055\uff94" +
    "\001\002\000\004\055\021\001\002\000\004\057\010\001" +
    "\002\000\004\055\021\001\002\000\010\055\uff91\073\uff90" +
    "\102\uff91\001\002\000\004\055\uff96\001\002\000\004\055" +
    "\uff95\001\002\000\004\057\010\001\002\000\004\005\ufffa" +
    "\001\002\000\004\055\021\001\002\000\010\005\uff99\026" +
    "\166\037\161\001\002\000\004\055\uff97\001\002\000\004" +
    "\005\174\001\002\000\022\005\174\022\uff65\024\223\027" +
    "\204\053\214\055\uff65\057\010\064\226\001\002\000\006" +
    "\055\uff76\056\uff76\001\002\000\006\055\ufff9\056\ufff9\001" +
    "\002\000\006\022\uff72\055\uff72\001\002\000\006\022\uff73" +
    "\055\uff73\001\002\000\006\022\uff64\055\uff64\001\002\000" +
    "\020\022\uff51\055\uff51\056\uff5b\061\uff5b\071\uff5b\073\353" +
    "\104\uff5b\001\002\000\012\056\343\061\u0106\071\341\104" +
    "\342\001\002\000\004\064\226\001\002\000\006\022\uff71" +
    "\055\uff71\001\002\000\006\022\uff62\055\uff62\001\002\000" +
    "\006\022\uff66\055\uff66\001\002\000\076\007\uff59\011\uff59" +
    "\012\uff59\013\uff59\014\uff59\015\uff59\016\uff59\017\uff59\020" +
    "\uff59\021\uff59\022\uff59\031\uff59\045\uff59\055\uff59\056\uff59" +
    "\061\uff59\062\uff59\063\uff59\065\uff59\066\uff59\067\uff59\070" +
    "\uff59\071\uff59\072\uff59\074\uff59\075\uff59\100\uff59\102\uff59" +
    "\103\uff59\104\uff59\001\002\000\006\022\uff6c\055\uff6c\001" +
    "\002\000\004\062\u0102\001\002\000\006\022\uff69\055\uff69" +
    "\001\002\000\004\057\010\001\002\000\006\022\uff63\055" +
    "\uff63\001\002\000\006\022\uff6b\055\uff6b\001\002\000\006" +
    "\022\uff6a\055\uff6a\001\002\000\006\022\uff6d\055\uff6d\001" +
    "\002\000\006\022\uff6f\055\uff6f\001\002\000\004\020\367" +
    "\001\002\000\004\057\010\001\002\000\006\022\uff68\055" +
    "\uff68\001\002\000\006\022\232\055\021\001\002\000\012" +
    "\022\ufff1\055\ufff1\062\ufff1\063\ufff1\001\002\000\076\007" +
    "\uff5a\011\uff5a\012\uff5a\013\uff5a\014\uff5a\015\uff5a\016\uff5a" +
    "\017\uff5a\020\uff5a\021\uff5a\022\uff5a\031\uff5a\045\uff5a\055" +
    "\uff5a\056\uff5a\061\uff5a\062\uff5a\063\uff5a\065\uff5a\066\uff5a" +
    "\067\uff5a\070\uff5a\071\uff5a\072\uff5a\074\uff5a\075\uff5a\100" +
    "\uff5a\102\uff5a\103\uff5a\104\uff5a\001\002\000\006\022\uff67" +
    "\055\uff67\001\002\000\022\005\174\022\uff65\024\223\027" +
    "\204\053\214\055\uff65\057\010\064\226\001\002\000\010" +
    "\022\uff75\055\uff75\056\uff75\001\002\000\006\022\uff74\055" +
    "\uff74\001\002\000\004\061\uff49\001\002\000\004\061\236" +
    "\001\002\000\032\010\242\012\073\014\044\034\244\057" +
    "\010\060\241\064\267\071\261\073\245\101\264\111\243" +
    "\112\256\001\002\000\076\007\uff5b\011\uff5b\012\uff5b\013" +
    "\uff5b\014\uff5b\015\uff5b\016\uff5b\017\uff5b\020\uff5b\021\uff5b" +
    "\022\uff5b\031\uff5b\045\uff5b\055\uff5b\056\uff5b\062\uff5b\063" +
    "\uff5b\065\uff5b\066\uff5b\067\uff5b\070\uff5b\071\uff5b\072\uff5b" +
    "\073\353\074\uff5b\075\uff5b\100\uff5b\102\uff5b\103\uff5b\104" +
    "\uff5b\001\002\000\074\007\uff37\011\uff37\012\uff37\013\uff37" +
    "\014\uff37\015\uff37\016\uff37\017\uff37\020\uff37\021\uff37\022" +
    "\uff37\031\uff37\045\uff37\055\uff37\056\343\062\uff37\063\uff37" +
    "\065\uff37\066\uff37\067\uff37\070\uff37\071\341\072\uff37\074" +
    "\uff37\075\uff37\100\uff37\102\uff37\103\uff37\104\342\001\002" +
    "\000\066\007\uff2e\011\uff2e\012\uff2e\013\uff2e\014\uff2e\015" +
    "\uff2e\016\uff2e\017\uff2e\020\uff2e\021\uff2e\022\uff2e\031\uff2e" +
    "\045\uff2e\055\uff2e\062\uff2e\063\uff2e\065\uff2e\066\uff2e\067" +
    "\uff2e\070\uff2e\072\uff2e\074\uff2e\075\uff2e\100\uff2e\102\uff2e" +
    "\103\uff2e\001\002\000\026\010\242\034\244\057\010\060" +
    "\241\064\267\071\261\073\245\101\264\111\243\112\256" +
    "\001\002\000\066\007\uff31\011\uff31\012\uff31\013\uff31\014" +
    "\uff31\015\uff31\016\uff31\017\uff31\020\uff31\021\uff31\022\uff31" +
    "\031\uff31\045\uff31\055\uff31\062\uff31\063\uff31\065\uff31\066" +
    "\uff31\067\uff31\070\uff31\072\uff31\074\uff31\075\uff31\100\uff31" +
    "\102\uff31\103\uff31\001\002\000\066\007\uff2d\011\uff2d\012" +
    "\uff2d\013\uff2d\014\uff2d\015\uff2d\016\uff2d\017\uff2d\020\uff2d" +
    "\021\uff2d\022\uff2d\031\uff2d\045\uff2d\055\uff2d\062\uff2d\063" +
    "\uff2d\065\uff2d\066\uff2d\067\uff2d\070\uff2d\072\uff2d\074\uff2d" +
    "\075\uff2d\100\uff2d\102\uff2d\103\uff2d\001\002\000\032\010" +
    "\242\012\073\014\044\034\244\057\010\060\241\064\267" +
    "\071\261\073\245\101\264\111\243\112\256\001\002\000" +
    "\064\007\uff3a\011\uff3a\012\uff3a\013\uff3a\014\uff3a\015\uff3a" +
    "\016\uff3a\017\uff3a\020\uff3a\021\uff3a\022\uff3a\031\uff3a\045" +
    "\uff3a\055\uff3a\062\uff3a\063\uff3a\065\uff3a\066\uff3a\067\uff3a" +
    "\070\uff3a\072\uff3a\074\uff3a\075\uff3a\100\uff3a\102\uff3a\001" +
    "\002\000\006\021\uff48\045\uff48\001\002\000\066\007\uff2c" +
    "\011\uff2c\012\uff2c\013\uff2c\014\uff2c\015\uff2c\016\uff2c\017" +
    "\uff2c\020\uff2c\021\uff2c\022\uff2c\031\uff2c\045\uff2c\055\uff2c" +
    "\062\uff2c\063\uff2c\065\uff2c\066\uff2c\067\uff2c\070\uff2c\072" +
    "\uff2c\074\uff2c\075\uff2c\100\uff2c\102\uff2c\103\uff2c\001\002" +
    "\000\064\007\uff3d\011\uff3d\012\uff3d\013\uff3d\014\uff3d\015" +
    "\uff3d\016\uff3d\017\uff3d\020\uff3d\021\uff3d\022\uff3d\031\uff3d" +
    "\045\uff3d\055\uff3d\062\uff3d\063\uff3d\065\uff3d\066\uff3d\067" +
    "\uff3d\070\uff3d\072\uff3d\074\uff3d\075\uff3d\100\uff3d\102\uff3d" +
    "\001\002\000\064\007\331\011\uff3f\012\uff3f\013\326\014" +
    "\uff3f\015\333\016\327\017\332\020\uff3f\021\uff3f\022\uff3f" +
    "\031\uff3f\045\uff3f\055\uff3f\062\uff3f\063\uff3f\065\uff3f\066" +
    "\uff3f\067\uff3f\070\uff3f\072\uff3f\074\uff3f\075\uff3f\100\uff3f" +
    "\102\uff3f\001\002\000\066\007\uff36\011\uff36\012\uff36\013" +
    "\uff36\014\uff36\015\uff36\016\uff36\017\uff36\020\uff36\021\uff36" +
    "\022\uff36\031\uff36\045\uff36\055\uff36\062\uff36\063\uff36\065" +
    "\uff36\066\uff36\067\uff36\070\uff36\072\uff36\074\uff36\075\uff36" +
    "\100\uff36\102\uff36\103\uff36\001\002\000\052\011\324\012" +
    "\311\014\316\020\uff41\021\uff41\022\uff41\031\313\045\uff41" +
    "\055\uff41\062\uff41\063\uff41\065\uff41\066\315\067\314\070" +
    "\320\072\317\074\323\075\312\100\uff41\102\uff41\001\002" +
    "\000\066\007\uff34\011\uff34\012\uff34\013\uff34\014\uff34\015" +
    "\uff34\016\uff34\017\uff34\020\uff34\021\uff34\022\uff34\031\uff34" +
    "\045\uff34\055\uff34\062\uff34\063\uff34\065\uff34\066\uff34\067" +
    "\uff34\070\uff34\072\uff34\074\uff34\075\uff34\100\uff34\102\uff34" +
    "\103\uff34\001\002\000\066\007\uff30\011\uff30\012\uff30\013" +
    "\uff30\014\uff30\015\uff30\016\uff30\017\uff30\020\uff30\021\uff30" +
    "\022\uff30\031\uff30\045\uff30\055\uff30\062\uff30\063\uff30\065" +
    "\uff30\066\uff30\067\uff30\070\uff30\072\uff30\074\uff30\075\uff30" +
    "\100\uff30\102\uff30\103\uff30\001\002\000\066\007\uff39\011" +
    "\uff39\012\uff39\013\uff39\014\uff39\015\uff39\016\uff39\017\uff39" +
    "\020\uff39\021\uff39\022\uff39\031\uff39\045\uff39\055\uff39\062" +
    "\uff39\063\uff39\065\uff39\066\uff39\067\uff39\070\uff39\072\uff39" +
    "\074\uff39\075\uff39\100\uff39\102\uff39\103\307\001\002\000" +
    "\066\007\uff2f\011\uff2f\012\uff2f\013\uff2f\014\uff2f\015\uff2f" +
    "\016\uff2f\017\uff2f\020\uff2f\021\uff2f\022\uff2f\031\uff2f\045" +
    "\uff2f\055\uff2f\062\uff2f\063\uff2f\065\uff2f\066\uff2f\067\uff2f" +
    "\070\uff2f\072\uff2f\074\uff2f\075\uff2f\100\uff2f\102\uff2f\103" +
    "\uff2f\001\002\000\034\010\242\012\073\014\044\034\244" +
    "\057\010\060\241\064\267\071\261\073\245\100\277\101" +
    "\264\111\243\112\256\001\002\000\066\007\uff35\011\uff35" +
    "\012\uff35\013\uff35\014\uff35\015\uff35\016\uff35\017\uff35\020" +
    "\uff35\021\uff35\022\uff35\031\uff35\045\uff35\055\uff35\062\uff35" +
    "\063\uff35\065\uff35\066\uff35\067\uff35\070\uff35\072\uff35\074" +
    "\uff35\075\uff35\100\uff35\102\uff35\103\uff35\001\002\000\006" +
    "\021\273\045\271\001\002\000\066\007\uff29\011\uff29\012" +
    "\uff29\013\uff29\014\uff29\015\uff29\016\uff29\017\uff29\020\uff29" +
    "\021\uff29\022\uff29\031\uff29\045\uff29\055\uff29\062\uff29\063" +
    "\uff29\065\uff29\066\uff29\067\uff29\070\uff29\072\uff29\074\uff29" +
    "\075\uff29\100\uff29\102\uff29\103\uff29\001\002\000\032\010" +
    "\242\012\073\014\044\034\244\057\010\060\241\064\267" +
    "\071\261\073\245\101\264\111\243\112\256\001\002\000" +
    "\066\007\uff2b\011\uff2b\012\uff2b\013\uff2b\014\uff2b\015\uff2b" +
    "\016\uff2b\017\uff2b\020\uff2b\021\uff2b\022\uff2b\031\uff2b\045" +
    "\uff2b\055\uff2b\062\uff2b\063\uff2b\065\uff2b\066\uff2b\067\uff2b" +
    "\070\uff2b\072\uff2b\074\uff2b\075\uff2b\100\uff2b\102\uff2b\103" +
    "\uff2b\001\002\000\066\007\uff2a\011\uff2a\012\uff2a\013\uff2a" +
    "\014\uff2a\015\uff2a\016\uff2a\017\uff2a\020\uff2a\021\uff2a\022" +
    "\uff2a\031\uff2a\045\uff2a\055\uff2a\062\uff2a\063\uff2a\065\uff2a" +
    "\066\uff2a\067\uff2a\070\uff2a\072\uff2a\074\uff2a\075\uff2a\100" +
    "\uff2a\102\uff2a\103\uff2a\001\002\000\064\007\uff3b\011\uff3b" +
    "\012\uff3b\013\uff3b\014\uff3b\015\uff3b\016\uff3b\017\uff3b\020" +
    "\uff3b\021\uff3b\022\uff3b\031\uff3b\045\uff3b\055\uff3b\062\uff3b" +
    "\063\uff3b\065\uff3b\066\uff3b\067\uff3b\070\uff3b\072\uff3b\074" +
    "\uff3b\075\uff3b\100\uff3b\102\uff3b\001\002\000\032\010\uff47" +
    "\012\uff47\014\uff47\034\uff47\057\uff47\060\uff47\064\uff47\071" +
    "\uff47\073\uff47\101\uff47\111\uff47\112\uff47\001\002\000\032" +
    "\010\242\012\073\014\044\034\244\057\010\060\241\064" +
    "\267\071\261\073\245\101\264\111\243\112\256\001\002" +
    "\000\032\010\uff46\012\uff46\014\uff46\034\uff46\057\uff46\060" +
    "\uff46\064\uff46\071\uff46\073\uff46\101\uff46\111\uff46\112\uff46" +
    "\001\002\000\004\020\uff45\001\002\000\004\020\uff61\001" +
    "\002\000\010\063\uff24\065\305\100\uff24\001\002\000\066" +
    "\007\uff26\011\uff26\012\uff26\013\uff26\014\uff26\015\uff26\016" +
    "\uff26\017\uff26\020\uff26\021\uff26\022\uff26\031\uff26\045\uff26" +
    "\055\uff26\062\uff26\063\uff26\065\uff26\066\uff26\067\uff26\070" +
    "\uff26\072\uff26\074\uff26\075\uff26\100\uff26\102\uff26\103\uff26" +
    "\001\002\000\010\063\uff22\065\uff22\100\uff22\001\002\000" +
    "\006\063\015\100\303\001\002\000\032\010\242\012\073" +
    "\014\044\034\244\057\010\060\241\064\267\071\261\073" +
    "\245\101\264\111\243\112\256\001\002\000\066\007\uff27" +
    "\011\uff27\012\uff27\013\uff27\014\uff27\015\uff27\016\uff27\017" +
    "\uff27\020\uff27\021\uff27\022\uff27\031\uff27\045\uff27\055\uff27" +
    "\062\uff27\063\uff27\065\uff27\066\uff27\067\uff27\070\uff27\072" +
    "\uff27\074\uff27\075\uff27\100\uff27\102\uff27\103\uff27\001\002" +
    "\000\010\063\uff25\065\305\100\uff25\001\002\000\032\010" +
    "\242\012\073\014\044\034\244\057\010\060\241\064\267" +
    "\071\261\073\245\101\264\111\243\112\256\001\002\000" +
    "\010\063\uff23\065\uff23\100\uff23\001\002\000\026\010\242" +
    "\034\244\057\010\060\241\064\267\071\261\073\245\101" +
    "\264\111\243\112\256\001\002\000\064\007\uff38\011\uff38" +
    "\012\uff38\013\uff38\014\uff38\015\uff38\016\uff38\017\uff38\020" +
    "\uff38\021\uff38\022\uff38\031\uff38\045\uff38\055\uff38\062\uff38" +
    "\063\uff38\065\uff38\066\uff38\067\uff38\070\uff38\072\uff38\074" +
    "\uff38\075\uff38\100\uff38\102\uff38\001\002\000\032\010\uff20" +
    "\012\uff20\014\uff20\034\uff20\057\uff20\060\uff20\064\uff20\071" +
    "\uff20\073\uff20\101\uff20\111\uff20\112\uff20\001\002\000\032" +
    "\010\uff18\012\uff18\014\uff18\034\uff18\057\uff18\060\uff18\064" +
    "\uff18\071\uff18\073\uff18\101\uff18\111\uff18\112\uff18\001\002" +
    "\000\032\010\uff13\012\uff13\014\uff13\034\uff13\057\uff13\060" +
    "\uff13\064\uff13\071\uff13\073\uff13\101\uff13\111\uff13\112\uff13" +
    "\001\002\000\032\010\uff14\012\uff14\014\uff14\034\uff14\057" +
    "\uff14\060\uff14\064\uff14\071\uff14\073\uff14\101\uff14\111\uff14" +
    "\112\uff14\001\002\000\032\010\uff19\012\uff19\014\uff19\034" +
    "\uff19\057\uff19\060\uff19\064\uff19\071\uff19\073\uff19\101\uff19" +
    "\111\uff19\112\uff19\001\002\000\032\010\uff21\012\uff21\014" +
    "\uff21\034\uff21\057\uff21\060\uff21\064\uff21\071\uff21\073\uff21" +
    "\101\uff21\111\uff21\112\uff21\001\002\000\032\010\uff15\012" +
    "\uff15\014\uff15\034\uff15\057\uff15\060\uff15\064\uff15\071\uff15" +
    "\073\uff15\101\uff15\111\uff15\112\uff15\001\002\000\032\010" +
    "\uff16\012\uff16\014\uff16\034\uff16\057\uff16\060\uff16\064\uff16" +
    "\071\uff16\073\uff16\101\uff16\111\uff16\112\uff16\001\002\000" +
    "\032\010\242\012\073\014\044\034\244\057\010\060\241" +
    "\064\267\071\261\073\245\101\264\111\243\112\256\001" +
    "\002\000\032\010\242\012\073\014\044\034\244\057\010" +
    "\060\241\064\267\071\261\073\245\101\264\111\243\112" +
    "\256\001\002\000\032\010\uff17\012\uff17\014\uff17\034\uff17" +
    "\057\uff17\060\uff17\064\uff17\071\uff17\073\uff17\101\uff17\111" +
    "\uff17\112\uff17\001\002\000\032\010\uff1f\012\uff1f\014\uff1f" +
    "\034\uff1f\057\uff1f\060\uff1f\064\uff1f\071\uff1f\073\uff1f\101" +
    "\uff1f\111\uff1f\112\uff1f\001\002\000\064\007\331\011\uff3e" +
    "\012\uff3e\013\326\014\uff3e\015\333\016\327\017\332\020" +
    "\uff3e\021\uff3e\022\uff3e\031\uff3e\045\uff3e\055\uff3e\062\uff3e" +
    "\063\uff3e\065\uff3e\066\uff3e\067\uff3e\070\uff3e\072\uff3e\074" +
    "\uff3e\075\uff3e\100\uff3e\102\uff3e\001\002\000\032\010\uff1e" +
    "\012\uff1e\014\uff1e\034\uff1e\057\uff1e\060\uff1e\064\uff1e\071" +
    "\uff1e\073\uff1e\101\uff1e\111\uff1e\112\uff1e\001\002\000\032" +
    "\010\uff1b\012\uff1b\014\uff1b\034\uff1b\057\uff1b\060\uff1b\064" +
    "\uff1b\071\uff1b\073\uff1b\101\uff1b\111\uff1b\112\uff1b\001\002" +
    "\000\032\010\242\012\073\014\044\034\244\057\010\060" +
    "\241\064\267\071\261\073\245\101\264\111\243\112\256" +
    "\001\002\000\032\010\uff1a\012\uff1a\014\uff1a\034\uff1a\057" +
    "\uff1a\060\uff1a\064\uff1a\071\uff1a\073\uff1a\101\uff1a\111\uff1a" +
    "\112\uff1a\001\002\000\032\010\uff1d\012\uff1d\014\uff1d\034" +
    "\uff1d\057\uff1d\060\uff1d\064\uff1d\071\uff1d\073\uff1d\101\uff1d" +
    "\111\uff1d\112\uff1d\001\002\000\032\010\uff1c\012\uff1c\014" +
    "\uff1c\034\uff1c\057\uff1c\060\uff1c\064\uff1c\071\uff1c\073\uff1c" +
    "\101\uff1c\111\uff1c\112\uff1c\001\002\000\064\007\uff3c\011" +
    "\uff3c\012\uff3c\013\uff3c\014\uff3c\015\uff3c\016\uff3c\017\uff3c" +
    "\020\uff3c\021\uff3c\022\uff3c\031\uff3c\045\uff3c\055\uff3c\062" +
    "\uff3c\063\uff3c\065\uff3c\066\uff3c\067\uff3c\070\uff3c\072\uff3c" +
    "\074\uff3c\075\uff3c\100\uff3c\102\uff3c\001\002\000\034\011" +
    "\324\012\311\014\316\020\uff40\021\uff40\022\uff40\045\uff40" +
    "\055\uff40\062\uff40\063\uff40\065\uff40\100\uff40\102\uff40\001" +
    "\002\000\004\102\337\001\002\000\066\007\uff33\011\uff33" +
    "\012\uff33\013\uff33\014\uff33\015\uff33\016\uff33\017\uff33\020" +
    "\uff33\021\uff33\022\uff33\031\uff33\045\uff33\055\uff33\062\uff33" +
    "\063\uff33\065\uff33\066\uff33\067\uff33\070\uff33\072\uff33\074" +
    "\uff33\075\uff33\100\uff33\102\uff33\103\uff33\001\002\000\066" +
    "\007\uff32\011\uff32\012\uff32\013\uff32\014\uff32\015\uff32\016" +
    "\uff32\017\uff32\020\uff32\021\uff32\022\uff32\031\uff32\045\uff32" +
    "\055\uff32\062\uff32\063\uff32\065\uff32\066\uff32\067\uff32\070" +
    "\uff32\072\uff32\074\uff32\075\uff32\100\uff32\102\uff32\103\uff32" +
    "\001\002\000\032\010\242\012\073\014\044\034\244\057" +
    "\010\060\241\064\267\071\261\073\245\101\264\111\243" +
    "\112\256\001\002\000\076\007\uff58\011\uff58\012\uff58\013" +
    "\uff58\014\uff58\015\uff58\016\uff58\017\uff58\020\uff58\021\uff58" +
    "\022\uff58\031\uff58\045\uff58\055\uff58\056\uff58\061\uff58\062" +
    "\uff58\063\uff58\065\uff58\066\uff58\067\uff58\070\uff58\071\uff58" +
    "\072\uff58\074\uff58\075\uff58\100\uff58\102\uff58\103\uff58\104" +
    "\uff58\001\002\000\004\057\010\001\002\000\076\007\uff53" +
    "\011\uff53\012\uff53\013\uff53\014\uff53\015\uff53\016\uff53\017" +
    "\uff53\020\uff53\021\uff53\022\uff53\031\uff53\045\uff53\055\uff53" +
    "\056\uff53\061\uff53\062\uff53\063\uff53\065\uff53\066\uff53\067" +
    "\uff53\070\uff53\071\uff53\072\uff53\074\uff53\075\uff53\100\uff53" +
    "\102\uff53\103\uff53\104\uff53\001\002\000\006\063\015\100" +
    "\351\001\002\000\006\063\uff54\100\uff54\001\002\000\006" +
    "\063\uff55\100\uff55\001\002\000\032\010\242\012\073\014" +
    "\044\034\244\057\010\060\241\064\267\071\261\073\245" +
    "\101\264\111\243\112\256\001\002\000\076\007\uff57\011" +
    "\uff57\012\uff57\013\uff57\014\uff57\015\uff57\016\uff57\017\uff57" +
    "\020\uff57\021\uff57\022\uff57\031\uff57\045\uff57\055\uff57\056" +
    "\uff57\061\uff57\062\uff57\063\uff57\065\uff57\066\uff57\067\uff57" +
    "\070\uff57\071\uff57\072\uff57\074\uff57\075\uff57\100\uff57\102" +
    "\uff57\103\uff57\104\uff57\001\002\000\006\063\uff56\100\uff56" +
    "\001\002\000\032\010\242\012\073\014\044\034\244\057" +
    "\010\060\241\064\267\071\261\073\245\101\264\111\243" +
    "\112\256\001\002\000\066\007\uff28\011\uff28\012\uff28\013" +
    "\uff28\014\uff28\015\uff28\016\uff28\017\uff28\020\uff28\021\uff28" +
    "\022\uff28\031\uff28\045\uff28\055\uff28\062\uff28\063\uff28\065" +
    "\uff28\066\uff28\067\uff28\070\uff28\072\uff28\074\uff28\075\uff28" +
    "\100\uff28\102\uff28\103\uff28\001\002\000\006\063\uff4e\102" +
    "\uff4e\001\002\000\010\062\363\063\uff4d\102\uff4d\001\002" +
    "\000\006\063\015\102\361\001\002\000\032\010\242\012" +
    "\073\014\044\034\244\057\010\060\241\064\267\071\261" +
    "\073\245\101\264\111\243\112\256\001\002\000\066\007" +
    "\uff50\011\uff50\012\uff50\013\uff50\014\uff50\015\uff50\016\uff50" +
    "\017\uff50\020\uff50\021\uff50\022\uff50\031\uff50\045\uff50\055" +
    "\uff50\062\uff50\063\uff50\065\uff50\066\uff50\067\uff50\070\uff50" +
    "\072\uff50\074\uff50\075\uff50\100\uff50\102\uff50\103\uff50\001" +
    "\002\000\006\063\uff4f\102\uff4f\001\002\000\032\010\242" +
    "\012\073\014\044\034\244\057\010\060\241\064\267\071" +
    "\261\073\245\101\264\111\243\112\256\001\002\000\010" +
    "\062\365\063\uff4c\102\uff4c\001\002\000\032\010\242\012" +
    "\073\014\044\034\244\057\010\060\241\064\267\071\261" +
    "\073\245\101\264\111\243\112\256\001\002\000\006\063" +
    "\uff4b\102\uff4b\001\002\000\022\005\174\022\uff65\024\223" +
    "\027\204\053\214\055\uff65\057\010\064\226\001\002\000" +
    "\006\022\uff60\055\uff60\001\002\000\006\022\uff5f\055\uff5f" +
    "\001\002\000\006\020\376\063\015\001\002\000\014\020" +
    "\uff43\056\343\063\uff43\071\341\104\342\001\002\000\014" +
    "\020\uff5b\056\uff5b\063\uff5b\071\uff5b\104\uff5b\001\002\000" +
    "\004\057\010\001\002\000\022\005\174\022\uff65\024\223" +
    "\027\204\053\214\055\uff65\057\010\064\226\001\002\000" +
    "\006\022\uff5e\055\uff5e\001\002\000\006\022\uff5d\055\uff5d" +
    "\001\002\000\014\020\uff44\056\343\063\uff44\071\341\104" +
    "\342\001\002\000\020\005\174\022\uff65\024\223\027\204" +
    "\053\214\055\uff65\057\010\001\002\000\006\022\uff6e\055" +
    "\uff6e\001\002\000\006\022\uff70\055\uff70\001\002\000\006" +
    "\022\uff4a\055\uff4a\001\002\000\032\010\242\012\073\014" +
    "\044\034\244\057\010\060\241\064\267\071\261\073\245" +
    "\101\264\111\243\112\256\001\002\000\006\022\uff5c\055" +
    "\uff5c\001\002\000\006\022\uff52\055\uff52\001\002\000\010" +
    "\055\uff78\062\u010a\073\uff78\001\002\000\046\004\101\012" +
    "\073\014\044\036\056\041\072\042\070\044\065\057\055" +
    "\060\050\064\105\073\061\077\066\101\077\104\063\105" +
    "\075\106\064\107\100\110\051\001\002\000\006\055\uff79" +
    "\102\uff79\001\002\000\006\055\uff7c\102\uff7c\001\002\000" +
    "\004\073\u010f\001\002\000\006\055\uff8f\102\uff8f\001\002" +
    "\000\012\026\166\037\161\052\u0115\057\014\001\002\000" +
    "\006\055\uff87\102\uff87\001\002\000\004\073\uff7b\001\002" +
    "\000\006\055\uff82\102\uff82\001\002\000\006\055\uff89\102" +
    "\uff89\001\002\000\006\055\uff83\102\uff83\001\002\000\004" +
    "\057\014\001\002\000\006\055\021\102\u011d\001\002\000" +
    "\006\055\uff86\102\uff86\001\002\000\006\062\u011b\063\015" +
    "\001\002\000\006\055\uff8a\102\uff8a\001\002\000\006\055" +
    "\uff88\102\uff88\001\002\000\046\004\101\012\073\014\044" +
    "\036\056\041\072\042\070\044\065\057\055\060\050\064" +
    "\105\073\061\077\066\101\077\104\063\105\075\106\064" +
    "\107\100\110\051\001\002\000\006\055\uff85\102\uff85\001" +
    "\002\000\010\055\uff8c\062\uff8c\102\uff8c\001\002\000\012" +
    "\026\166\037\161\052\u0115\057\014\001\002\000\006\055" +
    "\uff8b\102\uff8b\001\002\000\006\062\u0121\063\015\001\002" +
    "\000\046\004\101\012\073\014\044\036\056\041\072\042" +
    "\070\044\065\057\055\060\050\064\105\073\061\077\066" +
    "\101\077\104\063\105\075\106\064\107\100\110\051\001" +
    "\002\000\006\055\uff84\102\uff84\001\002\000\004\073\u010f" +
    "\001\002\000\004\062\u0125\001\002\000\046\004\101\012" +
    "\073\014\044\036\056\041\072\042\070\044\065\057\055" +
    "\060\050\064\105\073\061\077\066\101\077\104\063\105" +
    "\075\106\064\107\100\110\051\001\002\000\006\055\uff7a" +
    "\102\uff7a\001\002\000\026\003\023\005\ufff4\006\ufff4\025" +
    "\u0128\026\ufff4\033\024\037\ufff4\043\u0129\046\ufff4\052\ufff4" +
    "\001\002\000\004\055\uff8e\001\002\000\004\055\uff8d\001" +
    "\002\000\004\055\uff92\001\002\000\004\055\uff93\001\002" +
    "\000\004\055\uff80\001\002\000\010\055\uff81\073\uff81\102" +
    "\uff81\001\002\000\026\003\023\005\ufff4\006\ufff4\025\u0128" +
    "\026\ufff4\033\024\037\ufff4\043\u0129\046\ufff4\052\ufff4\001" +
    "\002\000\004\055\uff7d\001\002\000\004\055\uff77\001\002" +
    "\000\004\055\uff7f\001\002\000\022\003\023\005\ufff4\006" +
    "\ufff4\026\ufff4\033\024\037\ufff4\046\ufff4\052\ufff4\001\002" +
    "\000\004\055\uff7e\001\002\000\014\003\u0135\005\uffa0\026" +
    "\uffa0\037\uffa0\057\014\001\002\000\004\055\uff9b\001\002" +
    "\000\006\062\u0138\063\015\001\002\000\014\003\uff9d\005" +
    "\uff9d\026\uff9d\037\uff9d\057\uff9d\001\002\000\046\004\101" +
    "\012\073\014\044\036\056\041\072\042\070\044\065\057" +
    "\055\060\050\064\105\073\061\077\066\101\077\104\063" +
    "\105\075\106\064\107\100\110\051\001\002\000\004\055" +
    "\021\001\002\000\014\003\uff9c\005\uff9c\026\uff9c\037\uff9c" +
    "\057\uff9c\001\002\000\004\055\021\001\002\000\014\003" +
    "\uff9a\005\uff9a\026\uff9a\037\uff9a\057\uff9a\001\002\000\014" +
    "\003\uff9e\005\uff9e\026\uff9e\037\uff9e\057\uff9e\001\002\000" +
    "\004\055\uffeb\001\002\000\004\066\u0143\001\002\000\020" +
    "\003\uffed\005\uffed\026\uffed\037\uffed\046\uffed\052\uffed\057" +
    "\uffed\001\002\000\020\003\u013e\005\ufff0\026\ufff0\037\ufff0" +
    "\046\ufff0\052\ufff0\057\010\001\002\000\020\003\uffee\005" +
    "\uffee\026\uffee\037\uffee\046\uffee\052\uffee\057\uffee\001\002" +
    "\000\024\010\u0147\012\073\014\044\034\244\057\010\060" +
    "\241\064\267\073\u0149\101\264\001\002\000\032\011\324" +
    "\012\311\014\316\031\313\055\uffe9\066\315\067\314\070" +
    "\320\072\317\074\323\075\312\102\uffe9\001\002\000\046" +
    "\007\uffe1\011\uffe1\012\uffe1\013\uffe1\014\uffe1\015\uffe1\016" +
    "\uffe1\017\uffe1\031\uffe1\055\uffe1\066\uffe1\067\uffe1\070\uffe1" +
    "\072\uffe1\074\uffe1\075\uffe1\102\uffe1\103\u0156\001\002\000" +
    "\046\007\uffdf\011\uffdf\012\uffdf\013\uffdf\014\uffdf\015\uffdf" +
    "\016\uffdf\017\uffdf\031\uffdf\055\uffdf\066\uffdf\067\uffdf\070" +
    "\uffdf\072\uffdf\074\uffdf\075\uffdf\102\uffdf\103\uffdf\001\002" +
    "\000\020\010\u0147\034\244\057\010\060\241\064\267\073" +
    "\u0149\101\264\001\002\000\044\007\uffe2\011\uffe2\012\uffe2" +
    "\013\uffe2\014\uffe2\015\uffe2\016\uffe2\017\uffe2\031\uffe2\055" +
    "\uffe2\066\uffe2\067\uffe2\070\uffe2\072\uffe2\074\uffe2\075\uffe2" +
    "\102\uffe2\001\002\000\024\010\u0147\012\073\014\044\034" +
    "\244\057\010\060\241\064\267\073\u0149\101\264\001\002" +
    "\000\046\007\uffdd\011\uffdd\012\uffdd\013\uffdd\014\uffdd\015" +
    "\uffdd\016\uffdd\017\uffdd\031\uffdd\055\uffdd\066\uffdd\067\uffdd" +
    "\070\uffdd\072\uffdd\074\uffdd\075\uffdd\102\uffdd\103\uffdd\001" +
    "\002\000\004\055\021\001\002\000\044\007\uffe5\011\uffe5" +
    "\012\uffe5\013\uffe5\014\uffe5\015\uffe5\016\uffe5\017\uffe5\031" +
    "\uffe5\055\uffe5\066\uffe5\067\uffe5\070\uffe5\072\uffe5\074\uffe5" +
    "\075\uffe5\102\uffe5\001\002\000\044\007\331\011\uffe7\012" +
    "\uffe7\013\326\014\uffe7\015\333\016\327\017\332\031\uffe7" +
    "\055\uffe7\066\uffe7\067\uffe7\070\uffe7\072\uffe7\074\uffe7\075" +
    "\uffe7\102\uffe7\001\002\000\024\010\u0147\012\073\014\044" +
    "\034\244\057\010\060\241\064\267\073\u0149\101\264\001" +
    "\002\000\044\007\uffe3\011\uffe3\012\uffe3\013\uffe3\014\uffe3" +
    "\015\uffe3\016\uffe3\017\uffe3\031\uffe3\055\uffe3\066\uffe3\067" +
    "\uffe3\070\uffe3\072\uffe3\074\uffe3\075\uffe3\102\uffe3\001\002" +
    "\000\024\010\u0147\012\073\014\044\034\244\057\010\060" +
    "\241\064\267\073\u0149\101\264\001\002\000\044\007\uffe4" +
    "\011\uffe4\012\uffe4\013\uffe4\014\uffe4\015\uffe4\016\uffe4\017" +
    "\uffe4\031\uffe4\055\uffe4\066\uffe4\067\uffe4\070\uffe4\072\uffe4" +
    "\074\uffe4\075\uffe4\102\uffe4\001\002\000\020\003\uffec\005" +
    "\uffec\026\uffec\037\uffec\046\uffec\052\uffec\057\uffec\001\002" +
    "\000\004\102\u0154\001\002\000\046\007\uffde\011\uffde\012" +
    "\uffde\013\uffde\014\uffde\015\uffde\016\uffde\017\uffde\031\uffde" +
    "\055\uffde\066\uffde\067\uffde\070\uffde\072\uffde\074\uffde\075" +
    "\uffde\102\uffde\103\uffde\001\002\000\046\007\uffdc\011\uffdc" +
    "\012\uffdc\013\uffdc\014\uffdc\015\uffdc\016\uffdc\017\uffdc\031" +
    "\uffdc\055\uffdc\066\uffdc\067\uffdc\070\uffdc\072\uffdc\074\uffdc" +
    "\075\uffdc\102\uffdc\103\uffdc\001\002\000\020\010\u0147\034" +
    "\244\057\010\060\241\064\267\073\u0149\101\264\001\002" +
    "\000\044\007\uffe0\011\uffe0\012\uffe0\013\uffe0\014\uffe0\015" +
    "\uffe0\016\uffe0\017\uffe0\031\uffe0\055\uffe0\066\uffe0\067\uffe0" +
    "\070\uffe0\072\uffe0\074\uffe0\075\uffe0\102\uffe0\001\002\000" +
    "\024\010\u0147\012\073\014\044\034\244\057\010\060\241" +
    "\064\267\073\u0149\101\264\001\002\000\024\010\u0147\012" +
    "\073\014\044\034\244\057\010\060\241\064\267\073\u0149" +
    "\101\264\001\002\000\044\007\331\011\uffe6\012\uffe6\013" +
    "\326\014\uffe6\015\333\016\327\017\332\031\uffe6\055\uffe6" +
    "\066\uffe6\067\uffe6\070\uffe6\072\uffe6\074\uffe6\075\uffe6\102" +
    "\uffe6\001\002\000\014\011\324\012\311\014\316\055\uffe8" +
    "\102\uffe8\001\002\000\004\055\021\001\002\000\020\003" +
    "\uffea\005\uffea\026\uffea\037\uffea\046\uffea\052\uffea\057\uffea" +
    "\001\002\000\006\055\ufff2\063\ufff2\001\002\000\006\055" +
    "\021\063\015\001\002\000\004\064\226\001\002\000\016" +
    "\005\ufff7\006\ufff7\026\ufff7\037\ufff7\046\ufff7\052\ufff7\001" +
    "\002\000\006\055\ufff3\063\ufff3\001\002\000\004\055\021" +
    "\001\002\000\016\005\ufff5\006\ufff5\026\ufff5\037\ufff5\046" +
    "\ufff5\052\ufff5\001\002\000\004\002\000\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u0163\000\006\002\003\003\004\001\001\000\002\001" +
    "\001\000\004\174\021\001\001\000\004\170\006\001\001" +
    "\000\004\176\010\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\004\012\001\001\000\004\175\015\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\006\025\010\024\001\001\000\004\200\u0162\001\001\000" +
    "\006\011\u015e\012\u015d\001\001\000\004\013\030\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\014\u0140\015" +
    "\u013f\170\u013e\001\001\000\004\026\031\001\001\000\004" +
    "\064\154\001\001\000\010\027\036\030\034\170\033\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\202\040" +
    "\001\001\000\006\030\037\170\033\001\001\000\002\001" +
    "\001\000\004\174\041\001\001\000\002\001\001\000\042" +
    "\024\045\025\051\031\073\033\057\034\070\035\053\036" +
    "\066\037\056\040\102\041\075\046\061\057\103\061\046" +
    "\062\052\170\044\173\101\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\040\150" +
    "\041\075\046\061\057\103\061\046\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\004\146\001\001\000\002" +
    "\001\001\000\006\063\145\170\144\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\004\126\047" +
    "\125\050\124\051\123\001\001\000\002\001\001\000\004" +
    "\174\122\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\025\105\170\044\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\026\024\045" +
    "\025\051\034\113\035\053\036\066\042\111\043\112\044" +
    "\107\170\110\173\101\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\175\114\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\024\045\025\051\034\113\035\053" +
    "\036\066\043\121\044\107\170\110\173\101\001\001\000" +
    "\002\001\001\000\044\024\045\025\051\031\117\033\057" +
    "\034\070\035\053\036\066\037\056\040\102\041\075\045" +
    "\120\046\061\057\103\061\046\062\052\170\044\173\101" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\174\131\001\001\000\004\175\015\001\001\000" +
    "\042\024\045\025\051\031\130\033\057\034\070\035\053" +
    "\036\066\037\056\040\102\041\075\046\061\057\103\061" +
    "\046\062\052\170\044\173\101\001\001\000\002\001\001" +
    "\000\010\004\126\050\134\051\133\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\024\024\045\025\051\034\113\035" +
    "\053\036\066\044\140\060\141\170\110\173\101\001\001" +
    "\000\002\001\001\000\002\001\001\000\044\024\045\025" +
    "\051\031\117\033\057\034\070\035\053\036\066\037\056" +
    "\040\102\041\075\045\143\046\061\057\103\061\046\062" +
    "\052\170\044\173\101\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\175\015\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\024\152\025\051" +
    "\170\044\173\101\001\001\000\002\001\001\000\010\004" +
    "\u0135\065\u0133\066\u0136\001\001\000\024\067\166\070\167" +
    "\071\163\072\164\073\161\104\162\105\155\110\156\111" +
    "\157\001\001\000\006\174\u0131\205\u0122\001\001\000\002" +
    "\001\001\000\004\174\u012d\001\001\000\004\170\u012c\001" +
    "\001\000\004\174\u0126\001\001\000\004\204\u010c\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\170\u0108\001" +
    "\001\000\004\177\172\001\001\000\004\174\170\001\001" +
    "\000\020\071\171\072\164\073\161\104\162\105\155\110" +
    "\156\111\157\001\001\000\002\001\001\000\006\113\175" +
    "\114\174\001\001\000\056\005\221\012\211\114\212\115" +
    "\224\116\177\117\176\120\204\121\217\122\220\123\205" +
    "\124\206\125\200\126\223\127\214\130\227\131\210\132" +
    "\202\133\226\136\207\137\215\143\216\170\201\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\140\u0107\001\001" +
    "\000\002\001\001\000\004\012\u0104\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\132\372\133\226\136\207\147\371\170\373\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\144\234\170\233\001\001\000\002\001\001\000\004\174" +
    "\230\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\054\005\221\012\211\114\212\116\232\117" +
    "\176\120\204\121\217\122\220\123\205\124\206\125\200" +
    "\126\223\127\214\130\227\131\210\132\202\133\226\136" +
    "\207\137\215\143\216\170\201\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\046\132\237\133\226\136\207\145\262\151\246\152\253" +
    "\153\251\154\250\155\245\156\256\157\252\160\257\161" +
    "\247\162\265\163\261\164\254\170\236\173\264\001\001" +
    "\000\004\140\353\001\001\000\002\001\001\000\002\001" +
    "\001\000\030\132\237\133\226\136\207\156\337\157\252" +
    "\160\257\161\247\162\265\163\261\164\254\170\236\001" +
    "\001\000\002\001\001\000\002\001\001\000\044\132\237" +
    "\133\226\136\207\151\335\152\253\153\251\154\250\155" +
    "\245\156\256\157\252\160\257\161\247\162\265\163\261" +
    "\164\254\170\236\173\264\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\172\327\001\001\000\002\001\001\000\006\167\320\171" +
    "\321\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\050\132\237\133\226\136" +
    "\207\151\277\152\253\153\251\154\250\155\245\156\256" +
    "\157\252\160\257\161\247\162\265\163\261\164\254\165" +
    "\300\166\275\170\236\173\264\001\001\000\002\001\001" +
    "\000\004\106\271\001\001\000\002\001\001\000\036\132" +
    "\237\133\226\136\207\154\267\155\245\156\256\157\252" +
    "\160\257\161\247\162\265\163\261\164\254\170\236\173" +
    "\264\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\046\132\237\133\226\136" +
    "\207\146\274\151\273\152\253\153\251\154\250\155\245" +
    "\156\256\157\252\160\257\161\247\162\265\163\261\164" +
    "\254\170\236\173\264\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\175\301\001\001\000\046" +
    "\132\237\133\226\136\207\151\277\152\253\153\251\154" +
    "\250\155\245\156\256\157\252\160\257\161\247\162\265" +
    "\163\261\164\254\166\303\170\236\173\264\001\001\000" +
    "\002\001\001\000\002\001\001\000\044\132\237\133\226" +
    "\136\207\151\305\152\253\153\251\154\250\155\245\156" +
    "\256\157\252\160\257\161\247\162\265\163\261\164\254" +
    "\170\236\173\264\001\001\000\002\001\001\000\032\132" +
    "\237\133\226\136\207\155\307\156\256\157\252\160\257" +
    "\161\247\162\265\163\261\164\254\170\236\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\042\132\237" +
    "\133\226\136\207\152\334\153\251\154\250\155\245\156" +
    "\256\157\252\160\257\161\247\162\265\163\261\164\254" +
    "\170\236\173\264\001\001\000\040\132\237\133\226\136" +
    "\207\153\324\154\250\155\245\156\256\157\252\160\257" +
    "\161\247\162\265\163\261\164\254\170\236\173\264\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\172\327" +
    "\001\001\000\002\001\001\000\002\001\001\000\036\132" +
    "\237\133\226\136\207\154\333\155\245\156\256\157\252" +
    "\160\257\161\247\162\265\163\261\164\254\170\236\173" +
    "\264\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\171\321\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\050" +
    "\132\237\133\226\134\344\135\346\136\207\151\345\152" +
    "\253\153\251\154\250\155\245\156\256\157\252\160\257" +
    "\161\247\162\265\163\261\164\254\170\236\173\264\001" +
    "\001\000\002\001\001\000\004\170\343\001\001\000\002" +
    "\001\001\000\004\175\347\001\001\000\002\001\001\000" +
    "\002\001\001\000\046\132\237\133\226\135\351\136\207" +
    "\151\345\152\253\153\251\154\250\155\245\156\256\157" +
    "\252\160\257\161\247\162\265\163\261\164\254\170\236" +
    "\173\264\001\001\000\002\001\001\000\002\001\001\000" +
    "\050\132\237\133\226\136\207\141\356\142\354\151\355" +
    "\152\253\153\251\154\250\155\245\156\256\157\252\160" +
    "\257\161\247\162\265\163\261\164\254\170\236\173\264" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\175\357\001\001\000\046\132\237\133\226" +
    "\136\207\142\361\151\355\152\253\153\251\154\250\155" +
    "\245\156\256\157\252\160\257\161\247\162\265\163\261" +
    "\164\254\170\236\173\264\001\001\000\002\001\001\000" +
    "\002\001\001\000\044\132\237\133\226\136\207\151\363" +
    "\152\253\153\251\154\250\155\245\156\256\157\252\160" +
    "\257\161\247\162\265\163\261\164\254\170\236\173\264" +
    "\001\001\000\002\001\001\000\044\132\237\133\226\136" +
    "\207\151\365\152\253\153\251\154\250\155\245\156\256" +
    "\157\252\160\257\161\247\162\265\163\261\164\254\170" +
    "\236\173\264\001\001\000\002\001\001\000\052\005\221" +
    "\012\211\114\212\117\367\120\370\121\217\122\220\123" +
    "\205\124\206\125\200\126\223\127\214\130\227\131\210" +
    "\132\202\133\226\136\207\137\215\143\216\170\201\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\175\374" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\132" +
    "\u0100\133\226\136\207\170\373\001\001\000\052\005\221" +
    "\012\211\114\212\117\376\120\377\121\217\122\220\123" +
    "\205\124\206\125\200\126\223\127\214\130\227\131\210" +
    "\132\202\133\226\136\207\137\215\143\216\170\201\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\044\005\221\114\212\121\u0102\122\u0103\123\205\124" +
    "\206\125\200\126\223\127\214\130\227\131\210\132\202" +
    "\133\226\136\207\137\215\143\216\170\201\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\044" +
    "\132\237\133\226\136\207\151\u0106\152\253\153\251\154" +
    "\250\155\245\156\256\157\252\160\257\161\247\162\265" +
    "\163\261\164\254\170\236\173\264\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\044\024\045" +
    "\025\051\031\u010a\032\u010b\033\057\034\070\035\053\036" +
    "\066\037\056\040\102\041\075\046\061\057\103\061\046" +
    "\062\052\170\044\173\101\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\075\u010d\001\001\000\002\001\001" +
    "\000\030\004\u0117\073\u0113\076\u0115\077\u0118\100\u0112\101" +
    "\u0119\102\u010f\103\u0116\104\162\105\u0110\111\u0111\001\001" +
    "\000\002\001\001\000\004\205\u0122\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\004\u011f" +
    "\001\001\000\004\174\u011d\001\001\000\002\001\001\000" +
    "\004\175\015\001\001\000\002\001\001\000\002\001\001" +
    "\000\042\024\045\025\051\031\u011b\033\057\034\070\035" +
    "\053\036\066\037\056\040\102\041\075\046\061\057\103" +
    "\061\046\062\052\170\044\173\101\001\001\000\002\001" +
    "\001\000\002\001\001\000\026\004\u0117\073\u0113\077\u011e" +
    "\100\u0112\101\u0119\102\u010f\103\u0116\104\162\105\u0110\111" +
    "\u0111\001\001\000\002\001\001\000\004\175\015\001\001" +
    "\000\042\024\045\025\051\031\u0121\033\057\034\070\035" +
    "\053\036\066\037\056\040\102\041\075\046\061\057\103" +
    "\061\046\062\052\170\044\173\101\001\001\000\002\001" +
    "\001\000\004\075\u0123\001\001\000\002\001\001\000\044" +
    "\024\045\025\051\031\u010a\032\u0125\033\057\034\070\035" +
    "\053\036\066\037\056\040\102\041\075\046\061\057\103" +
    "\061\046\062\052\170\044\173\101\001\001\000\002\001" +
    "\001\000\012\006\u012b\010\024\074\u012a\107\u0129\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\006\u012f\010\024\074\u0130\112\u012e\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\006\u012f" +
    "\010\024\112\u0132\001\001\000\002\001\001\000\006\004" +
    "\u0135\066\u013c\001\001\000\004\203\u013a\001\001\000\004" +
    "\175\015\001\001\000\002\001\001\000\042\024\045\025" +
    "\051\031\u0138\033\057\034\070\035\053\036\066\037\056" +
    "\040\102\041\075\046\061\057\103\061\046\062\052\170" +
    "\044\173\101\001\001\000\004\174\u0139\001\001\000\002" +
    "\001\001\000\004\174\u013b\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\201\u015b\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\015\u0141\170\u013e\001\001\000" +
    "\002\001\001\000\032\016\u014a\017\u0143\020\u014c\021\u014b" +
    "\022\u0147\023\u0144\157\u0149\160\257\161\247\162\265\170" +
    "\u0145\173\u014d\001\001\000\006\167\u0157\171\u0158\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\023\u0154\157" +
    "\u0149\160\257\161\247\162\265\170\u0145\001\001\000\002" +
    "\001\001\000\032\016\u0152\017\u0143\020\u014c\021\u014b\022" +
    "\u0147\023\u0144\157\u0149\160\257\161\247\162\265\170\u0145" +
    "\173\u014d\001\001\000\002\001\001\000\004\174\u0151\001" +
    "\001\000\002\001\001\000\004\172\u014f\001\001\000\024" +
    "\021\u014e\022\u0147\023\u0144\157\u0149\160\257\161\247\162" +
    "\265\170\u0145\173\u014d\001\001\000\002\001\001\000\024" +
    "\021\u0150\022\u0147\023\u0144\157\u0149\160\257\161\247\162" +
    "\265\170\u0145\173\u014d\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\020\022\u0156\023\u0144\157\u0149\160\257\161\247" +
    "\162\265\170\u0145\001\001\000\002\001\001\000\030\017" +
    "\u015a\020\u014c\021\u014b\022\u0147\023\u0144\157\u0149\160\257" +
    "\161\247\162\265\170\u0145\173\u014d\001\001\000\026\020" +
    "\u0159\021\u014b\022\u0147\023\u0144\157\u0149\160\257\161\247" +
    "\162\265\170\u0145\173\u014d\001\001\000\004\172\u014f\001" +
    "\001\000\004\171\u0158\001\001\000\004\174\u015c\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\174\u0160\175" +
    "\u015f\001\001\000\004\012\u0161\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\174\u0163\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	TabelaDeSimbolos.inicializa();
	Tipo.criaTipos();

    }


    
    public static int errors = 0;
    public static StringBuffer code = new StringBuffer();
    
    public void report_error(String message, Object info) {
   
        
        StringBuilder m = new StringBuilder("Error");
   		errors++; 
          
        m.append(" : "+message);
   
        System.err.println("Error "+ Main.pascalLexer.current_lexeme() + " : Sintantic error");
        System.err.println(m + "" + (info instanceof String ? info : ""));
        
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    
    public void sem_error(String lexeme, String message) {
		errors ++;
		System.err.println("Error in line "+ Main.pascalLexer.current_line() + " : Erro semantico :-(");
      	System.err.println("==> " + message + ": "+ lexeme + "\n");
  	}
  	
  	public void sem_error(String message) {
		errors ++;
		System.err.println("Error "+ Main.pascalLexer.current_lexeme() + " : Erro semantico :-(");
      	System.err.println("==> " + message +"\n");
  	}
  	
    

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	class Exp {
	  public Tipo tipo;
	  public String code;
	  public boolean isConstant;

	  Exp(Tipo t, String code) {
		this(t, code, false);
	  }
	  
	  Exp(Tipo t, String code, boolean cte) {
		tipo = t;
		this.code = code;
		isConstant = cte;
	  }

	}
	
	class Reg {
		
		 
		public String id;
		public String val;
		
		Reg(String id) {
			this(id,"");
		}
		
		Reg(String id, String val) {
			this.id = id;
			this.val = val;
		}
	
	}
	
	public static String assembOp(String pascOper) {
		if(pascOper.equals("-")) {
			return "SUB";
		}
		else if(pascOper.equals("+")) {
			return "ADD";
		}
		else if(pascOper.equals("*")) {
			return "MUL";
		}
		else if(pascOper.equals("/") || pascOper.toLowerCase().equals("div")) {
			return "DIV";
		}
		return "";
	}
	
	/* listas auxiliares para gerenciar registradores */
	List<Reg> argRegs = new ArrayList<Reg> ();
	
	/* pesquisa um registrador argumento dado seu valor */
	public Reg getArgReg(String val) {
		for(Reg reg : argRegs) {
			if(reg.val.equals(val))
				return reg;
		}
		return null;
	}
	
	/* lista para gerenciar destino de laços (labels) */
	List<Integer> labels = new ArrayList<Integer>();
	
	/* variavel auxiliar para manipulacao de labels */
	int label = 0;
	

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // comma ::= COMMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("comma",123, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // semicolon ::= SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("semicolon",122, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // identifier ::= IDENTIFIER 
            {
              String RESULT =null;
		int xleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int xright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String x = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   								
   								RESULT = x; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier",118, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // relop ::= IN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // relop ::= GE 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // relop ::= LE 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // relop ::= GT 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // relop ::= LT 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // relop ::= NOTEQUAL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // relop ::= EQUAL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // mulop ::= AND 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = a; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",120, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // mulop ::= MOD 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = m; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",120, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // mulop ::= DIV 
            {
              String RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String d = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = d; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",120, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // mulop ::= SLASH 
            {
              String RESULT =null;
		int slleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int slright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String sl = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sl; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",120, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // mulop ::= STAR 
            {
              String RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",120, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // addop ::= OR 
            {
              String RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String o = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = o; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",119, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // addop ::= MINUS 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = m; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",119, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // addop ::= PLUS 
            {
              String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = p; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",119, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // member_designator ::= expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("member_designator",116, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // member_designator ::= member_designator DOTDOT expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("member_designator",116, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // member_designator_list ::= member_designator 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("member_designator_list",115, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // member_designator_list ::= member_designator_list comma member_designator 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("member_designator_list",115, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // set_constructor ::= LBRAC RBRAC 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("set_constructor",114, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // set_constructor ::= LBRAC member_designator_list RBRAC 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("set_constructor",114, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // function_designator ::= identifier params 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int prsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int prsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Exp> prs = (List<Exp>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							Simbolo t = null;
   							if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								parser.sem_error(id, "unknow name");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "?");
   							}
   							else {
								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoParametros().size() != prs.size()) {
   									parser.sem_error(id, "expected " + tf.getTipoParametros().size() + " parameters in function");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   								else {
   									for(int i = 0; i < prs.size(); i++) {
   										if(! tf.getTipoParametros().get(i).getVal().equals(prs.get(i).tipo.getVal())) {
   											parser.sem_error(id, "Tipos dos parametros passados sao imcompativeis com os parametros de");
   											RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   										} else {
											Reg argReg = argRegs.get(i);
											parser.code.append("\t LD "+argReg.id+" , "+prs.get(i).code +"\n"); 
   										}
   									}
   									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   									RESULT = new Exp(tf.getTipoRetorno(), "V0");
   								}
   							}
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_designator",113, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // unsigned_real ::= REALNUMBER 
            {
              Exp RESULT =null;
		int rnleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rnright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object rn = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(Tipo.getTipo(Tipo.REAL), ""+rn); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_real",112, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // unsigned_integer ::= DIGSEQ 
            {
              Exp RESULT =null;
		int dsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ds = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(Tipo.getTipo(Tipo.INTEGER), ""+ds); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_integer",111, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // unsigned_number ::= unsigned_real 
            {
              Exp RESULT =null;
		int urleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int urright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp ur = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(ur.tipo, ur.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_number",110, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // unsigned_number ::= unsigned_integer 
            {
              Exp RESULT =null;
		int uileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int uiright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp ui = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(ui.tipo, ui.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_number",110, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // unsigned_constant ::= NIL 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",109, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // unsigned_constant ::= CHARACTER_STRING 
            {
              Exp RESULT =null;
		int csleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int csright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String cs = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   						  RESULT = (cs.length() == 3) ? new Exp(Tipo.getTipo(Tipo.CHAR), cs) : 
														new Exp(Tipo.getTipo(Tipo.STRING), cs); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",109, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // unsigned_constant ::= unsigned_number 
            {
              Exp RESULT =null;
		int unleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int unright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp un = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(un.tipo, un.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",109, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // primary ::= FALSE 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), "0"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // primary ::= TRUE 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), "1"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // primary ::= NOT primary 
            {
              Exp RESULT =null;
		int prleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int prright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp pr = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 if(! pr.tipo.getVal().equals("boolean")) {
             		if(! pr.tipo.getVal().equals("error")) {
             			parser.sem_error(pr.tipo.getVal(), "The operator NOT is undefined for the expression type");
             		}
             		RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
             	}
             	else {
					parser.code.append("\t LD R0 , "+pr.code+"\n");
					parser.code.append("\t NOT R0\n");
					pr.code = "R0";
             		RESULT = pr;
             	}
             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",108, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // primary ::= LPAREN expression RPAREN 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
					if(getArgReg("temp") == null) {
						parser.code.append("\t LD R2 , "+exp.code+"\n");
						argRegs.add(new Reg("R2", "temp"));
						exp.code = "R2";
					}
					RESULT = exp; 
					
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",108, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // primary ::= set_constructor 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // primary ::= function_designator 
            {
              Exp RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp fd = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(fd.tipo, fd.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // primary ::= unsigned_constant 
            {
              Exp RESULT =null;
		int ucleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ucright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp uc = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(uc.tipo, "#"+uc.code, true); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // primary ::= variable_access 
            {
              Exp RESULT =null;
		int valeft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp va = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						if(va.tipo instanceof TipoFuncao) {
							TipoFuncao tf = (TipoFuncao) va.tipo;
   							if( tf.getTipoParametros().size() != 0) {
   								parser.sem_error("", "expected "+tf.getTipoParametros().size()
   											+" parameters in function");
								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							} else {
								parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   								parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   								parser.code.append("\t BR "+va.code+"\n"); 
   								parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								RESULT = new Exp(va.tipo,"V0");
   							}
   						} else {
							if(! TabelaDeSimbolos.escopoCorrente.isRoot()) {
									Reg arg = getArgReg(va.code);
									if(arg != null) {
										va.code = arg.id;
										//Se a variable_access for um argumento, carregar em regs diferentes
										parser.code.append("\t LD R"+va.code.charAt(1)+" , "+va.code +"\n"); 
										RESULT =  new Exp(va.tipo, "R"+va.code.charAt(1));
									}
									else {
										parser.code.append("\t LD R0 , "+va.code +"\n");
										RESULT =  new Exp(va.tipo, "R0"); 
									}
							}
							else {
								parser.code.append("\t LD R0 , "+va.code +"\n");
								RESULT =  new Exp(va.tipo, "R0"); 
							}
						}
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // exponentiation ::= primary STARSTAR exponentiation 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exponentiation",107, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // exponentiation ::= primary 
            {
              Exp RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp p = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
						RESULT = new Exp(p.tipo, p.code, p.isConstant); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exponentiation",107, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // factor ::= exponentiation 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(exp.tipo, exp.code, exp.isConstant); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",106, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // factor ::= sign factor 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String sn = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp f = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   				if(sn.toLowerCase().equals("-")) {
   					if(! (f.tipo.getVal().equals("integer") || f.tipo.getVal().equals("real"))) {
   						parser.sem_error(f.tipo.getVal(), "The operator - is undefined for the expression type");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					}
   					else {
   						RESULT = f;
   					}
   				}
   				else if(sn.toLowerCase().equals("+")) {
   					if(! (f.tipo.getVal().equals("integer") || f.tipo.getVal().equals("real")
   							|| f.tipo.getVal().equals("string") || f.tipo.getVal().equals("char"))) {
   						parser.sem_error(f.tipo.getVal(), "The operator + is undefined for the expression type");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					}
   					else {
   						RESULT = f;
   					}
   				}
   			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",106, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // term ::= term mulop factor 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int adleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int adright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String ad = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int teleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						if(ad != null) {
   							if(ad.toLowerCase().equals("and")) {
   								if(!(se.tipo.getVal().equals("boolean") && te.tipo.getVal().equals("boolean"))) {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator AND is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   								else {
									if(! "R1".equals(se.code))
										parser.code.append("\t LD R1 , "+se.code+"\n");
									se.code = "R1";
									parser.code.append("\t AND "+se.code+" , "+se.code+" , "+te.code+"\n");
   									RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), se.code);
   								}
   							}
   							else if(ad.toLowerCase().equals("*") || ad.toLowerCase().equals("/")) {
   								if((se.tipo.getVal().equals("integer") || se.tipo.getVal().equals("real")) &&
   								  (te.tipo.getVal().equals("integer") || te.tipo.getVal().equals("real"))) {
   									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), se.code);
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   							}
   							else if(ad.toLowerCase().equals("mod") || ad.toLowerCase().equals("div")) {
   								if(se.tipo.getVal().equals("integer") && te.tipo.getVal().equals("integer")) {
									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.getTipo(Tipo.INTEGER), se.code);
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   							}
   						}
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",105, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // term ::= factor 
            {
              Exp RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp f = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(f.tipo, f.code, f.isConstant); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",105, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // simple_expression ::= simple_expression addop term 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int adleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int adright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String ad = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int teleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						if(ad != null) {
   							if(ad.toLowerCase().equals("or")) {
   								if(!(se.tipo.getVal().equals("boolean") && te.tipo.getVal().equals("boolean"))) {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator OR is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   								else {
									if(! "R1".equals(se.code))
										parser.code.append("\t LD R1 , "+se.code+"\n");
									se.code = "R1";
									parser.code.append("\t OR "+se.code+" , "+se.code+" , "+te.code+"\n");
   									RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), se.code);
   								}
   							}
   							else if(ad.toLowerCase().equals("-") || ad.toLowerCase().equals("+")) {
   								if((se.tipo.getVal().equals("integer") || se.tipo.getVal().equals("real")) &&
   								  (te.tipo.getVal().equals("integer") || te.tipo.getVal().equals("real"))) {
									
									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), se.code);
   								}
   								else if((se.tipo.getVal().equals("char") || se.tipo.getVal().equals("string")) &&
   								  (te.tipo.getVal().equals("char") || te.tipo.getVal().equals("string"))) {
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), "?");
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   							}
   							
   						}
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_expression",104, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // simple_expression ::= term 
            {
              Exp RESULT =null;
		int teleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
									RESULT = new Exp(te.tipo, te.code, te.isConstant); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_expression",104, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // expression ::= simple_expression relop simple_expression 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), ""); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",103, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // expression ::= simple_expression 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(se.tipo, se.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",103, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // boolean_expression ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   							if(exp != null) {
   								if(! exp.tipo.getVal().equals("boolean")) {
   									if(! exp.tipo.getVal().equals("error"))
   										parser.sem_error(exp.tipo.getVal(), "cannot convert to boolean ");
   							 		RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   								else {
   									RESULT = new Exp(exp.tipo, exp.code);
   								}
   							}
   						  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("boolean_expression",102, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // record_variable_list ::= variable_access 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_variable_list",101, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // record_variable_list ::= record_variable_list comma variable_access 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_variable_list",101, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // final_value ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("final_value",100, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // direction ::= DOWNTO 
            {
              String RESULT =null;
		 RESULT = "downTo"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("direction",68, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // direction ::= TO 
            {
              String RESULT =null;
		 RESULT = "to"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("direction",68, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // initial_value ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("initial_value",99, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // control_variable ::= identifier 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   							Simbolo t = null;
   							if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								parser.sem_error(id, "unknow name");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							} else if(t.getTipo().getVal().equals("char") || t.getTipo().getVal().equals("integer")){
   								RESULT = new Exp(t.getTipo(), id); 
   							}
   							else {
   								parser.sem_error("char or integer", "The type of control variable '"+id+"' must be ");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							}
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("control_variable",98, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // goto_statement ::= GOTO label 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("goto_statement",97, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // actual_parameter ::= expression COLON expression COLON expression 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",96, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // actual_parameter ::= expression COLON expression 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",96, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // actual_parameter ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",96, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // actual_parameter_list ::= actual_parameter 
            {
              List<Exp> RESULT =null;
		int apleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int apright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp ap = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   								List<Exp> l = new ArrayList<Exp>();
   								l.add(ap);
   								RESULT = l;
   							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter_list",95, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // actual_parameter_list ::= actual_parameter_list comma actual_parameter 
            {
              List<Exp> RESULT =null;
		int aplleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aplright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<Exp> apl = (List<Exp>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int apleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int apright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp ap = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   								apl.add(ap);
   								RESULT = apl;
   							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter_list",95, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // params ::= LPAREN actual_parameter_list RPAREN 
            {
              List<Exp> RESULT =null;
		int aplleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aplright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<Exp> apl = (List<Exp>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = apl; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("params",94, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // procedure_statement ::= identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							Simbolo t = null;
   							 if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								 parser.sem_error(id, "unknow name");
   								
   							 }
   							 else {
   								
   								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoParametros().size() != 0) {
   									parser.sem_error(id, "expected " + tf.getTipoParametros().size() + " parameters in function");
   									
   								} else {
									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								}
   							 }
   							
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_statement",93, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // procedure_statement ::= identifier params 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int prsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int prsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Exp> prs = (List<Exp>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							
   							 Simbolo t = null;
   							 if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								 parser.sem_error(id, "unknow name");
   								
   							 }
   							 else {
   								
   								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoParametros().size() != prs.size()) {
   									parser.sem_error(id, "expected " + tf.getTipoParametros().size() + " parameters in function");
   									
   								}
   								else {
   									for(int i = 0; i < prs.size(); i++) {
   										if(! tf.getTipoParametros().get(i).getVal().equals(prs.get(i).tipo.getVal())) {
   											parser.sem_error(id, "Tipos dos parametros passados sao imcompativeis com os parametros de");
   											
   										}
   										Reg argReg = new Reg("A"+i);
   										parser.code.append("\t LD "+argReg.id+" , "+prs.get(i).code+"\n"); 
   									}
   									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								}
   							 }
   							
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_statement",93, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // field_designator ::= variable_access DOT identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("field_designator",92, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // index_expression ::= expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_expression",91, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // index_expression_list ::= index_expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_expression_list",90, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // index_expression_list ::= index_expression_list comma index_expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_expression_list",90, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // indexed_variable ::= variable_access LBRAC index_expression_list RBRAC 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("indexed_variable",89, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // variable_access ::= variable_access UPARROW 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_access",88, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // variable_access ::= field_designator 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_access",88, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // variable_access ::= indexed_variable 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_access",88, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // variable_access ::= identifier 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   					Simbolo t = null;
   					if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   						parser.sem_error(id, "unknow name");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					} else {
   						RESULT = new Exp(t.getTipo(), id); 
   					}
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_access",88, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // assignment_statement ::= variable_access ASSIGNMENT expression 
            {
              Tipo RESULT =null;
		int tvaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tvaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp tva = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int texpleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int texpright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp texp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   							if( tva.tipo instanceof TipoFuncao ) {
								if(TabelaDeSimbolos.escopoCorrente.isRoot()) {
									parser.sem_error(tva.code, "retorno fora do escopo da funcao ");
									RESULT = Tipo.getTipo(Tipo.ERRO);
								}
								else {
								    TipoFuncao tf = (TipoFuncao) tva.tipo;
								    Tipo rt = tf.getTipoRetorno();
								    if(! rt.getVal().equals(texp.tipo.getVal())) {
									 if(! rt.getVal().equals("error") && ! rt.getVal().equals("error")) {
										 if(! (rt.getVal().equals("real") && texp.tipo.getVal().equals("integer"))) {
											 parser.sem_error(rt.getVal(), "cannot convert from "+ texp.tipo.getVal() + " to ");
											 RESULT = Tipo.getTipo(Tipo.ERRO);
										 }
									 }
									}
									else {
										tva.code = "V0";
										parser.code.append("\t LD "+tva.code+" , "+texp.code +"\n");
										RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
									}
								}
							}
   							else if(! tva.tipo.getVal().equals(texp.tipo.getVal())) {
   								if(! texp.tipo.getVal().equals("error") && ! tva.tipo.getVal().equals("error")) {
   									if(! (tva.tipo.getVal().equals("real") && texp.tipo.getVal().equals("integer"))) {
   										parser.sem_error(tva.tipo.getVal(), "cannot convert from "+ texp.tipo.getVal() + " to ");
   										RESULT = Tipo.getTipo(Tipo.ERRO);
   									}
   									else {
										parser.code.append("\t ST "+tva.code+" , "+texp.code +"\n");
   										RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
   									}
   								}
   						   }
   						   else {
								parser.code.append("\t ST "+tva.code+" , "+texp.code +"\n");
   						        RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
   						   }
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assignment_statement",87, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // closed_with_statement ::= WITH record_variable_list DO closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_with_statement",84, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // open_with_statement ::= WITH record_variable_list DO open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_with_statement",83, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // closed_for_statement ::= for_designator DO closed_statement 
            {
              Object RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> fd = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
								parser.code.append("\t LD R3 , "+fd.get(0)+"\n");
							    if(fd.get(1) != null && fd.get(1).toLowerCase().equals("to")) {
									parser.code.append("\t ADD R3 , R3 , #1\n");
								}
								else if(fd.get(1) != null && fd.get(1).toLowerCase().equals("downto")) {
									parser.code.append("\t SUB R3 , R3 , #1\n");
								}
								parser.code.append("\t ST "+fd.get(0)+" , R3\n");
								parser.code.append("\t BR "+fd.get(2)+"\n");
								parser.code.append(fd.get(3)+":\n");
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_for_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // open_for_statement ::= for_designator DO open_statement 
            {
              Object RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> fd = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
							parser.code.append("\t LD R3 , "+fd.get(0)+"\n");
							if(fd.get(1) != null && fd.get(1).toLowerCase().equals("to")) {
								parser.code.append("\t ADD R3 , R3 , #1\n");
							}
							else if(fd.get(1) != null && fd.get(1).toLowerCase().equals("downto")) {
								parser.code.append("\t SUB R3 , R3 , #1\n");
							}
                          	parser.code.append("\t ST "+fd.get(0)+" , R3\n");
                          	parser.code.append("\t BR "+fd.get(2)+"\n");
                          	parser.code.append(fd.get(3)+":\n");
                          	
                          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_for_statement",81, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // for_designator ::= FOR control_variable ASSIGNMENT initial_value direction final_value 
            {
              List<String> RESULT =null;
		int cvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int cvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Exp cv = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int ivleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ivright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp iv = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int dirleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int dirright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String dir = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fvright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp fv = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						String lbl1 = "", lblFalse = "";
						if(!cv.tipo.getVal().equals("error")) {
							if(!cv.tipo.getVal().equals(iv.tipo.getVal())) {
								parser.sem_error(cv.tipo.getVal(), "The type of initial value must be ");
							}
							else if(!cv.tipo.getVal().equals(fv.tipo.getVal())) {
								parser.sem_error(cv.tipo.getVal(), "The type of final value must be ");
							}
							else {
								parser.code.append("\t ST "+cv.code+" , "+iv.code+"\n");
								labels.add(labels.size()+1);
								lbl1 = "$L"+labels.size();
								parser.code.append(lbl1+":\n");
								parser.code.append("\t LD R4 , "+fv.code+"\n");
								parser.code.append("\t LD R3 , "+cv.code+"\n");
								parser.code.append("\t SUB R0 , R3 , R4\n");
								labels.add(labels.size()+1);
								lblFalse = "$L"+labels.size();
								if(dir != null && dir.toLowerCase().equals("to"))
									parser.code.append("\t BGTZ R0 , "+lblFalse+"\n");
								else if(dir != null && dir.toLowerCase().equals("downto"))
									parser.code.append("\t BLTZ R0 , "+lblFalse+"\n");
							}
						}
						List<String> forArgs = new ArrayList<String>();
						forArgs.add(cv.code);
						forArgs.add(dir);
						forArgs.add(lbl1);
						forArgs.add(lblFalse);
						RESULT = forArgs;
					  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_designator",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // non_labeled_open_statement ::= open_for_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_open_statement",80, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // non_labeled_open_statement ::= open_if_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_open_statement",80, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // non_labeled_open_statement ::= open_with_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_open_statement",80, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // non_labeled_closed_statement ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // non_labeled_closed_statement ::= closed_for_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // non_labeled_closed_statement ::= closed_if_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // non_labeled_closed_statement ::= closed_with_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // non_labeled_closed_statement ::= compound_statement 
            {
              Object RESULT =null;
		 	
											labels.add(labels.size()+1);
											parser.code.append("$L"+labels.size()+":\n");
										
              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // non_labeled_closed_statement ::= goto_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // non_labeled_closed_statement ::= procedure_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // non_labeled_closed_statement ::= assignment_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // closed_statement ::= non_labeled_closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_statement",78, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // closed_statement ::= label COLON non_labeled_closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_statement",78, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // open_statement ::= non_labeled_open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_statement",77, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // open_statement ::= label COLON non_labeled_open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_statement",77, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // statement ::= closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",76, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // statement ::= open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",76, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // statement_sequence ::= statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement_sequence",75, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // statement_sequence ::= statement_sequence semicolon statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement_sequence",75, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // compound_statement ::= BEGIN statement_sequence END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("compound_statement",74, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // statement_part ::= compound_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement_part",73, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // function_block ::= block 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_block",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // function_identification ::= FUNCTION identifier 
            {
              String RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
					if(! TabelaDeSimbolos.inserir(id.toLowerCase(), new Simbolo(id, new TipoFuncao(Tipo.getTipo(Tipo.TIPO_VOID))))) {
                            parser.sem_error(id, "duplicate name");
                            RESULT = null;
                    }
                    else {
						RESULT = id;
					} 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_identification",67, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // result_type ::= type_denoter 
            {
              Tipo RESULT =null;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = td; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("result_type",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // function_heading ::= function_identification NT$7 formal_parameter_list COLON result_type 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int fileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int firight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String fi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int fplleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fplright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<Tipo> fpl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rtleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rtright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo rt = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							
   							if(fi != null) {
								Simbolo s = TabelaDeSimbolos.get(fi.toLowerCase());
								TipoFuncao t = (TipoFuncao) s.getTipo();
								t.setTipoRetorno(rt);
								t.addParamTipo(fpl);
							}
                             
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_heading",71, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // NT$7 ::= 
            {
              Object RESULT =null;
		int fileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int firight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String fi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
TabelaDeSimbolos.push(); parser.code.append(fi+": \n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",131, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // function_heading ::= FUNCTION identifier COLON result_type 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rtleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rtright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo rt = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							if(! TabelaDeSimbolos.inserir(id.toLowerCase(), new Simbolo(id, new TipoFuncao(rt)))) {
                            	parser.sem_error(id, "duplicate name");
                            } else {
								TabelaDeSimbolos.push();
								parser.code.append(id+": \n");
                            } 
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_heading",71, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // function_declaration ::= function_heading semicolon function_block 
            {
              Object RESULT =null;
		
                              parser.code.append("\t BR *0(SP) \n"); 
                              TabelaDeSimbolos.pop();
                            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_declaration",70, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // function_declaration ::= function_identification semicolon function_block 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_declaration",70, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // function_declaration ::= function_heading semicolon directive 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_declaration",70, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // procedure_block ::= block 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_block",69, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // procedure_identification ::= PROCEDURE identifier 
            {
              String RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									
   									if(! TabelaDeSimbolos.inserir(id.toLowerCase(), new Simbolo(id, new TipoFuncao(Tipo.getTipo(Tipo.TIPO_VOID))))) {
                            			parser.sem_error(id, "duplicate name");
                            			RESULT = "";
                            		}
                            		else {
                            			RESULT = id;
                            		}
                        		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_identification",66, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // functional_parameter_specification ::= function_heading 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("functional_parameter_specification",65, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // procedural_parameter_specification ::= procedure_heading 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedural_parameter_specification",64, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // variable_parameter_specification ::= VAR identifier_list COLON type_denoter 
            {
              List<Tipo> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
								/* para facilitar, consideramos que as duas formas recebem parâmetros */
										 
   									    List<Tipo> l = new ArrayList<Tipo>();
   									    int i = 0;
   										for(String id : il) {
                            				if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td))) {
                            					parser.sem_error(id, "duplicate name");
                            				}
                            				l.add(td);
                            				argRegs.add(new Reg("A"+i, id));
											i++;
                            			}
                            			RESULT = l;
   								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_parameter_specification",63, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // value_parameter_specification ::= identifier_list COLON type_denoter 
            {
              List<Tipo> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   								    List<Tipo> l = new ArrayList<Tipo>();
   									for(String id : il) {
                            			if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td))) {
                            				parser.sem_error(id, "duplicate name");
                            			}
                            			l.add(td);
                            			argRegs.add(new Reg("A"+argRegs.size(), id));
                            		}
                            		RESULT = l;
   								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("value_parameter_specification",62, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // formal_parameter_section ::= functional_parameter_specification 
            {
              List<Tipo> RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",61, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // formal_parameter_section ::= procedural_parameter_specification 
            {
              List<Tipo> RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",61, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // formal_parameter_section ::= variable_parameter_specification 
            {
              List<Tipo> RESULT =null;
		int varpsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varpsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> varps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = varps; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",61, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // formal_parameter_section ::= value_parameter_specification 
            {
              List<Tipo> RESULT =null;
		int vpsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vpsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> vps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = vps; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",61, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // formal_parameter_section_list ::= formal_parameter_section 
            {
              List<Tipo> RESULT =null;
		int fpsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fpsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> fps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                   List<Tipo> l = new ArrayList<Tipo>();
                                   for(Tipo t : fps) {
                                   		l.add(t);
                                   } 
                                   RESULT = l;
                                   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section_list",60, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // formal_parameter_section_list ::= formal_parameter_section_list semicolon formal_parameter_section 
            {
              List<Tipo> RESULT =null;
		int fpslleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fpslright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<Tipo> fpsl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int fpsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fpsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> fps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
										for(Tipo t : fps) {
											fpsl.add(t);
										} 
										RESULT = fpsl;
                                   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section_list",60, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // formal_parameter_list ::= LPAREN formal_parameter_section_list RPAREN 
            {
              List<Tipo> RESULT =null;
		int fpslleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fpslright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<Tipo> fpsl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = fpsl; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_list",59, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // directive ::= EXTERNAL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("directive",58, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // directive ::= FORWARD 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("directive",58, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // procedure_heading ::= procedure_identification NT$6 formal_parameter_list 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int pileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int piright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int fplleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fplright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> fpl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 Simbolo s = TabelaDeSimbolos.get(pi.toLowerCase());
                            if(s != null) {
								TipoFuncao t = (TipoFuncao) s.getTipo();
								t.addParamTipo(fpl);
							}
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_heading",57, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // NT$6 ::= 
            {
              Object RESULT =null;
		int pileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int piright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 TabelaDeSimbolos.push(); parser.code.append(pi+": \n"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",130, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // procedure_heading ::= procedure_identification 
            {
              Object RESULT =null;
		int pileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int piright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		TabelaDeSimbolos.push(); parser.code.append(pi+": \n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_heading",57, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // procedure_declaration ::= procedure_heading semicolon procedure_block 
            {
              Object RESULT =null;
		
								parser.code.append("\t BR *0(SP) \n");
								TabelaDeSimbolos.pop();
                             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_declaration",56, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // procedure_declaration ::= procedure_heading semicolon directive 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_declaration",56, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // proc_or_func_declaration ::= function_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration",55, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // proc_or_func_declaration ::= procedure_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration",55, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // proc_or_func_declaration_list ::= proc_or_func_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration_list",54, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // proc_or_func_declaration_list ::= proc_or_func_declaration_list semicolon proc_or_func_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration_list",54, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // procedure_and_function_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_and_function_declaration_part",53, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // procedure_and_function_declaration_part ::= proc_or_func_declaration_list semicolon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_and_function_declaration_part",53, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // variable_declaration ::= error NT$5 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration",52, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // NT$5 ::= 
            {
              Object RESULT =null;
 parser.report_error("","expected ';' before token"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",129, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // variable_declaration ::= identifier_list COLON type_denoter semicolon 
            {
              Object RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                            	for(String id : il) {
                            		if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td))) {
                            			parser.sem_error(id, "duplicate name");
                            		}
                            	}
   							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration",52, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // variable_declaration_list ::= variable_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_list",51, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // variable_declaration_list ::= variable_declaration_list variable_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_list",51, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // variable_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_part",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // variable_declaration_part ::= VAR variable_declaration_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_part",50, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // domain_type ::= identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("domain_type",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // new_pointer_type ::= UPARROW domain_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_pointer_type",48, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // file_type ::= PFILE OF component_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("file_type",47, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // base_type ::= ordinal_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("base_type",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // set_type ::= SET OF base_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("set_type",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // tag_type ::= identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tag_type",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // tag_field ::= identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tag_field",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // variant_list ::= variant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_list",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // variant_list ::= variant_list semicolon variant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_list",41, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // variant_selector ::= tag_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_selector",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // variant_selector ::= tag_field COLON tag_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_selector",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // record_section ::= identifier_list COLON type_denoter 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_section",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // record_section_list ::= record_section 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_section_list",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // record_section_list ::= record_section_list semicolon record_section 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_section_list",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // record_type ::= RECORD variant_part END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_type",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // record_type ::= RECORD record_section_list semicolon variant_part END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_type",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // record_type ::= RECORD record_section_list END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_type",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // component_type ::= type_denoter 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // ordinal_type ::= identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ordinal_type",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // ordinal_type ::= new_ordinal_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ordinal_type",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // index_type ::= ordinal_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_type",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // index_list ::= index_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_list",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // index_list ::= index_list comma index_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_list",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // array_type ::= ARRAY LBRAC index_list RBRAC OF component_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_type",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // structured_type ::= file_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("structured_type",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // structured_type ::= set_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("structured_type",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // structured_type ::= record_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("structured_type",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // structured_type ::= array_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("structured_type",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // new_structured_type ::= PACKED structured_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_structured_type",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // new_structured_type ::= structured_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_structured_type",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // subrange_type ::= constant DOTDOT constant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subrange_type",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // enumerated_type ::= LPAREN identifier_list RPAREN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("enumerated_type",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // new_ordinal_type ::= subrange_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_ordinal_type",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // new_ordinal_type ::= enumerated_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_ordinal_type",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // new_type ::= new_pointer_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_type",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // new_type ::= new_structured_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_type",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // new_type ::= new_ordinal_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_type",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // type_denoter ::= BOOLEAN 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.BOOLEAN); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // type_denoter ::= REAL 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.REAL); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // type_denoter ::= CHAR 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.CHAR); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // type_denoter ::= INTEGER 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.INTEGER); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // type_denoter ::= STRING 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.STRING); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // type_denoter ::= new_type 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // type_denoter ::= IDENTIFIER 
            {
              Tipo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						Simbolo t = null;
   						if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   							parser.sem_error(id, "undefined type");
   							RESULT = Tipo.getTipo(Tipo.ERRO);
   						} else {
   							RESULT = t.getTipo(); 
   						}
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // type_definition ::= error NT$4 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // NT$4 ::= 
            {
              Object RESULT =null;
 parser.report_error("","expected ';' before token"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",128, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // type_definition ::= identifier EQUAL type_denoter semicolon 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td, true))) {
                            	parser.sem_error(id, "duplicate name");
                       } 
                     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // type_definition_list ::= type_definition 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition_list",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // type_definition_list ::= type_definition_list type_definition 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition_list",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // type_definition_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition_part",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // type_definition_part ::= TYPE type_definition_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition_part",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // non_string ::= REALNUMBER 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_string",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // non_string ::= identifier 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_string",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // non_string ::= DIGSEQ 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_string",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // sign ::= MINUS 
            {
              String RESULT =null;
		int mnleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mnright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String mn = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = mn; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sign",121, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // sign ::= PLUS 
            {
              String RESULT =null;
		int plleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int plright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String pl = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = pl; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sign",121, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // constant ::= CHARACTER_STRING 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // constant ::= sign non_string 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // constant ::= non_string 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // cprimary ::= NOT cprimary 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cprimary",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // cprimary ::= unsigned_constant 
            {
              Tipo RESULT =null;
		int ucleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ucright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp uc = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT  = uc.tipo; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cprimary",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // cprimary ::= LPAREN cexpression RPAREN 
            {
              Tipo RESULT =null;
		int celeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int ceright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo ce = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = ce; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cprimary",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // cprimary ::= identifier 
            {
              Tipo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   				    Simbolo t = null;
   					if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   						parser.sem_error(id, "unknow name");
   						RESULT = Tipo.getTipo(Tipo.ERRO);
   					} else {
   						RESULT = t.getTipo(); 
   					}
   				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cprimary",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // cexponentiation ::= cprimary STARSTAR cexponentiation 
            {
              Tipo RESULT =null;
		int cpleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cpright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Tipo cp = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = cp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cexponentiation",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // cexponentiation ::= cprimary 
            {
              Tipo RESULT =null;
		int cpleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cpright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo cp = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = cp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cexponentiation",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // cfactor ::= cexponentiation 
            {
              Tipo RESULT =null;
		int celeft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ceright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo ce = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = ce; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cfactor",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // cfactor ::= sign cfactor 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cfactor",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // cterm ::= cterm mulop cfactor 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cterm",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // cterm ::= cfactor 
            {
              Tipo RESULT =null;
		int cfleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cfright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo cf = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = cf; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cterm",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // csimple_expression ::= csimple_expression addop cterm 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("csimple_expression",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // csimple_expression ::= cterm 
            {
              Tipo RESULT =null;
		int ctleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ctright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo ct = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = ct; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("csimple_expression",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // cexpression ::= csimple_expression relop csimple_expression 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cexpression",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // cexpression ::= csimple_expression 
            {
              Tipo RESULT =null;
		int cseleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cseright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo cse = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = cse; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cexpression",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // constant_definition ::= error NT$3 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_definition",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // NT$3 ::= 
            {
              Object RESULT =null;
 parser.report_error("","expected ';' before token"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",127, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // constant_definition ::= identifier EQUAL cexpression semicolon 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tceleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tceright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo tce = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, tce, true))) {
                            	parser.sem_error(id, "duplicate name");
                            }  
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_definition",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // constant_list ::= constant_definition 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_list",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // constant_list ::= constant_list constant_definition 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_list",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // constant_definition_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_definition_part",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // constant_definition_part ::= CONST constant_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_definition_part",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // label ::= DIGSEQ 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // label_list ::= label 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_list",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // label_list ::= label_list comma label 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_list",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // label_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // label_declaration_part ::= error NT$2 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // NT$2 ::= 
            {
              Object RESULT =null;
 parser.report_error("","expected ';' before token"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",126, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // label_declaration_part ::= LABEL label_list semicolon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // module ::= constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("module",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // block ::= label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part NT$1 statement_part 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("block",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // NT$1 ::= 
            {
              Object RESULT =null;
 
				 if(TabelaDeSimbolos.escopoCorrente.isRoot()) { 
					parser.code.append("main: \n");
				 } 
			   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",125, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // identifier_list ::= IDENTIFIER 
            {
              List<String> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		   List<String> il = new ArrayList<String>();
   					 						il.add(id.toLowerCase());
   					 						RESULT = il; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier_list",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // identifier_list ::= identifier_list comma IDENTIFIER 
            {
              List<String> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 il.add(id.toLowerCase()); RESULT = il; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier_list",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // program_heading ::= PROGRAM identifier NT$0 LPAREN identifier_list RPAREN 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("program_heading",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$0 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 
							parser.code.append("// Assembly code to "+id+" \n\n"); 
							parser.code.append("\t LD SP , #stackStart\n"); 
							parser.code.append("\t BR main \n"); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",124, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program_heading ::= PROGRAM identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
							parser.code.append("; Codigo assembly simples para "+id+".\n"); 
							parser.code.append("; Os registradores A0...An sao argumentos de funcoes/procedimentos.\n");
							parser.code.append("; O registrador V0 guarda retorno de funcoes.\n\n"); 
							parser.code.append("\t LD SP , #stackStart\n"); 
							parser.code.append("\t BR main \n"); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program_heading",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // program ::= program_heading semicolon block DOT 
            {
              Object RESULT =null;
		 parser.code.append("\t HALT \n\n"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

